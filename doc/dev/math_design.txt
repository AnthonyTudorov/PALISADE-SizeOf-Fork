1. Use templates to support uint8_t, uint16_t, uint32_t, uint64_t using the same math implementation. Example: BigBinaryInteger<uint64_t>. 

	template <class Integer>
	class BigBinaryInteger {...}

2. Use a separate namespace to define BigBinaryInteger, BigBinaryVector, and BigBinaryMatrix classes. Use namespace "cpu_int".

3. Create a folder called "cpu_int" under "math".

4. Add binint.h and binint.cpp to to "cpu_int".

5. BigBinaryInteger will implement BigBinaryIntegerInterface

6. Use operators but they should defined based on existing methods such as Plus, PlusTo, Times, TimesBy, etc. Operators should be as inline (outside the class but in the same header file; see the end of il2n.h for an example).

7. We are planning to use move semantics (C++ 11). And we are going to use expression templates depending on the result of performance evaluation for pilot methods.

8. Currently support only unsigned BigBinanryInteger classes. The support for signed integers can be added later via runtime polymorphism.

Constructors:
BigBinaryInteger();
explicit BigBinaryInteger(const std::string& str);
explicit BigBinaryInteger(const BigBinaryInteger& bigInteger);
BigBinaryInteger(BigBinaryInteger &&bigInteger);//move copy constructor
virtual BigBinaryInteger&  operator=(const BigBinaryInteger &rhs);
virtual BigBinaryInteger&  operator=(BigBinaryInteger &&rhs);
~BigBinaryInteger();
std::string ToString() const;



