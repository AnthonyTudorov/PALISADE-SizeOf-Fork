// This is a main() file built to test math  operations
// D. Cousins

#include <iostream>
#include <fstream>
#include "../../lib/utils/inttypes.h"
#include "../../lib/math/backend.h"
#if 1
#include "../../lib/math/nbtheory.h"
#include "../../lib/math/distrgen.h"
#include "../../lib/lattice/elemparams.h"
#include "../../lib/lattice/ilparams.h"
#include "../../lib/lattice/ildcrtparams.h"
#include "../../lib/lattice/ilelement.h"
#include "../../lib/crypto/lwecrypt.h"
#include "../../lib/obfuscate/lweconjunctionobfuscate.h"
#include "../../lib/obfuscate/lweconjunctionobfuscate.cpp"
#include "../../lib/obfuscate/obfuscatelp.h"
#endif
#include "time.h"
#include <chrono>

#include "../../lib/utils/debug.h"
#include <omp.h> //open MP header

using namespace std;
using namespace lbcrypto;


//define the main sections of the test
void test_BigBinaryInt(void); 	// test old version of big int
void test_BigBinaryVector(void); // test old version of big int vector
void test_ubintvec(void);	 // test new vector version

void test_BMM(void);

//main()   need this for Kurts' makefile to ignore this.
int main(int argc, char* argv[]){
  test_BMM();
  test_BigBinaryVector();
  test_ubintvec();
  
  return 0;
}

//Testing macro runs the desired code 
// res = fn
// an a loop nloop times, timed with timer t with res compared to testval

#define TESTIT(t, res, fn, testval, nloop) do {	\
  TIC(t); \
  for (usint j = 0; j< nloop; j++){\
    res = (fn);			   \
  }\
  time2 = TOC(t);\
  DEBUG(#t << ": " << nloop << " loops " << #res << " = " << #fn << " computation time: " << "\t" << time2 << " us"); \
  if (res != testval){\
    cout << "Bad " << #res << " = " << #fn << endl;\
    vec_diff(res, testval);\
  }\
 } while (0);


//helper function that bulds BigBinaryVector from a vector of strings
BigBinaryVector BBVfromStrvec( std::vector<std::string> &s) {
  BigBinaryVector a(s.size());
  for (usint i = 0; i< s.size(); i++){
    a.SetValAtIndex(i,s[i]);
  }
  return a;
}

//function to compare two BigBinaryVectors and print differing indicies
void vec_diff(BigBinaryVector &a, BigBinaryVector &b) {
    for (usint i= 0; i < a.GetLength(); ++i){  
      if (a.GetValAtIndex(i) != b.GetValAtIndex(i)) {
        cout << "i: "<< i << endl;
	cout << "first vector " <<endl;
        cout << a.GetValAtIndex(i);
        cout << endl;
	cout << "second vector " <<endl;
        cout << b.GetValAtIndex(i);
        cout << endl;

      }
    }

}

//main BigBinaryVector test suite. tests math
void test_BigBinaryVector () {
  cout<<"testing BigBinaryVector"<<endl;
  int nloop = 1000; //number of times to run each test for timing.

  bool dbg_flag = 1;		// if true then print dbg output

  TimeVar t1,t2,t3,t_total; // timers for TIC() TOC()
  double time1;		    // captures the time in usec.
  double time2;
  double time3;
  double timeTotal;		// overal time

  //there are three test cases, 1) small modulus 2)approx 48 bits. 3)
  //very big numbers

  //note this fails BigBinaryInteger q1 = {"00000000000000163841"};
  BigBinaryInteger q1 ("00000000000000163841");

  // for each vector, define a, b inputs as vectors of strings
  std::vector<std::string> a1strvec = {
    "00000000000000127753", "00000000000000077706",
    "00000000000000017133", "00000000000000022582",
    "00000000000000112132", "00000000000000027625",
    "00000000000000126773", "00000000000000008924",
    "00000000000000125972", "00000000000000002551",
    "00000000000000113837", "00000000000000112045",
    "00000000000000100953", "00000000000000077352",
    "00000000000000132013", "00000000000000057029", };

  // this fails too!!! BigBinaryVector a1(a1string);
  // so I wrote this function
  BigBinaryVector a1 = BBVfromStrvec(a1strvec);
  a1.SetModulus(q1);

  //b:
  std::vector<std::string> b1strvec = 
    { "00000000000000066773", "00000000000000069572",
      "00000000000000142134", "00000000000000141115",
      "00000000000000123182", "00000000000000155822",
      "00000000000000128147", "00000000000000094818",
      "00000000000000135782", "00000000000000030844",
      "00000000000000088634", "00000000000000099407",
      "00000000000000053647", "00000000000000111689",
      "00000000000000028502", "00000000000000026401", };
  
  BigBinaryVector b1  = BBVfromStrvec(b1strvec);
  b1.SetModulus(q1);
  
  //now test all mod functions Note BigBinaryVector implies modulus ALWAYS

  //load correct values of math functions of a and b
  //modadd:
  std::vector<std::string>  modsum1strvec =
    {"00000000000000030685", "00000000000000147278",
     "00000000000000159267", "00000000000000163697",
     "00000000000000071473", "00000000000000019606",
     "00000000000000091079", "00000000000000103742",
     "00000000000000097913", "00000000000000033395",
     "00000000000000038630", "00000000000000047611",
     "00000000000000154600", "00000000000000025200",
     "00000000000000160515", "00000000000000083430", };
  BigBinaryVector modsum1 = BBVfromStrvec(modsum1strvec);
  modsum1.SetModulus(q1);
  
  
  // modsub:
  std::vector<std::string>  moddiff1strvec =
    {   "00000000000000060980", "00000000000000008134",
	"00000000000000038840", "00000000000000045308",
	"00000000000000152791", "00000000000000035644",
	"00000000000000162467", "00000000000000077947",
	"00000000000000154031", "00000000000000135548",
	"00000000000000025203", "00000000000000012638",
	"00000000000000047306", "00000000000000129504",
	"00000000000000103511", "00000000000000030628", };
  BigBinaryVector moddiff1 = BBVfromStrvec(moddiff1strvec);
  moddiff1.SetModulus(q1);
  //modmul:
  
  std::vector<std::string> modmul1strvec =
    { "00000000000000069404", "00000000000000064196",
      "00000000000000013039", "00000000000000115321",
      "00000000000000028519", "00000000000000151998",
      "00000000000000089117", "00000000000000080908",
      "00000000000000057386", "00000000000000039364",
      "00000000000000008355", "00000000000000146135",
      "00000000000000061336", "00000000000000031598",
      "00000000000000025961", "00000000000000087680", };
  
  
  BigBinaryVector modmul1 = BBVfromStrvec(modmul1strvec);
  modmul1.SetModulus(q1);

  BigBinaryVector c1,c2,c3;	// result vectors

  // compute results for each function and compare.


  TESTIT(t1, c1, a1 + b1, modsum1, nloop);
  TESTIT(t1, c1, a1.ModAdd(b1), modsum1, nloop);
  TESTIT(t1, c1, a1 - b1, moddiff1, nloop);
  TESTIT(t1, c1, a1.ModSub(b1), moddiff1, nloop);
  TESTIT(t1, c1, a1 * b1, modmul1, nloop);
  TESTIT(t1, c1, a1.ModMul(b1), modmul1, nloop);

  //test case 2
  BigBinaryInteger q2 ("00004057816419532801");

  std::vector<std::string> a2strvec = {
    "00000185225172798255", "00000098879665709163",
    "00003497410031351258", "00004012431933509255",
    "00001543020758028581", "00000135094568432141",
    "00003976954337141739", "00004030348521557120",
    "00000175940803531155", "00000435236277692967",
    "00003304652649070144", "00002032520019613814",
    "00000375749152798379", "00003933203511673255",
    "00002293434116159938", "00001201413067178193", };

  BigBinaryVector a2 = BBVfromStrvec(a2strvec);
  a2.SetModulus(q2);

  std::vector<std::string> b2strvec = 
    { "00000698898215124963", "00000039832572186149",
      "00001835473200214782", "00001041547470449968",
      "00001076152419903743", "00000433588874877196",
      "00002336100673132075", "00002990190360138614",
      "00000754647536064726", "00000702097990733190",
      "00002102063768035483", "00000119786389165930",
      "00003976652902630043", "00003238750424196678",
      "00002978742255253796", "00002124827461185795", };

  BigBinaryVector b2 = BBVfromStrvec(b2strvec);
  b2.SetModulus(q2);

  std::vector<std::string> modsum2strvec =
    {"00000884123387923218", "00000138712237895312",
     "00001275066812033239", "00000996162984426422",
     "00002619173177932324", "00000568683443309337",
     "00002255238590741013", "00002962722462162933",
     "00000930588339595881", "00001137334268426157",
     "00001348899997572826", "00002152306408779744",
     "00000294585635895621", "00003114137516337132",
     "00001214359951880933", "00003326240528363988", };
  BigBinaryVector modsum2 = BBVfromStrvec(modsum2strvec);
  modsum2.SetModulus(q2);
  
  std::vector<std::string>  moddiff2strvec =
    {   "00003544143377206093", "00000059047093523014",
	"00001661936831136476", "00002970884463059287",
	"00000466868338124838", "00003759322113087746",
	"00001640853664009664", "00001040158161418506",
	"00003479109686999230", "00003790954706492578",
	"00001202588881034661", "00001912733630447884",
	"00000456912669701137", "00000694453087476577",
	"00003372508280438943", "00003134402025525199", };
  BigBinaryVector moddiff2 = BBVfromStrvec(moddiff2strvec);
  moddiff2.SetModulus(q2);
  
  std::vector<std::string> modmul2strvec =
    { "00000585473140075497", "00003637571624495703",
      "00001216097920193708", "00001363577444007558",
      "00000694070384788800", "00002378590980295187",
      "00000903406520872185", "00000559510929662332",
      "00000322863634303789", "00001685429502680940",
      "00001715852907773825", "00002521152917532260",
      "00000781959737898673", "00002334258943108700",
      "00002573793300043944", "00001273980645866111", };

  BigBinaryVector modmul2 = BBVfromStrvec(modmul2strvec);
  modmul2.SetModulus(q2);


  TESTIT(t2, c2, a2.ModAdd(b2), modsum2, nloop);
  TESTIT(t2, c2, a2.ModSub(b2), moddiff2, nloop);
  TESTIT(t2, c2, a2.ModMul(b2), modmul2, nloop);


  //test case 3

  //q3: very large numbers.
  BigBinaryInteger q3("3273390607896141870013189696827599152216642046043064789483291368096133796404674554883270092325904157150886684127560071009217256545885393053328527589431");

  std::vector<std::string> a3strvec = {
    "2259002487796164904665772121894078584543401744155154298312726209247751689172189255653866355964200768484575418973864307364757237946940733747446643725054",
    "1478743816308009734668992873633380110912159803397999015955212019971253231528589466789603074746010444199132421555598329082557053986240265071537647362089",
    "2442250766561334341166822783674395133995556495312318016431141348749482739749788174173081312927274880146329980363424977565638001056841245678661782610982",
    "917779106114096279364098211126816308037915672568153320523308800097705587686270523428976942621563981845568821206569141624247183330715577260930218556767",
    "214744931049447103852875386182628152420432967632133352449560778740158135437968557572597545037670326240142368149137864407874100658923913041236510842284",
    "3022931024526554241483841300690432083112912011870712018209552253068347592628043101662926263810401378532416655773738499681026278335470355055192240903881",
    "2177879458107855257699914331737144896274676269055062432826552808869348125407671199582563543692287114712642299482144959316835614426673048987634699368975",
    "297233451802123294436846683552230198845414118375785255038220841170372509047202030175469239142902723134737621108313142071558385068315554041062888072990"
  };

  BigBinaryVector a3 = BBVfromStrvec(a3strvec);
  a3.SetModulus(q3);

  std::vector<std::string> b3strvec = { 
    "1746404952192586268381151521422372143182145525977836700420382237240400642889251297954418325675184427789348433626369450669892557208439401215109489355089",
    "220598825371098531288665964851212313477741334812037568788443848101743931352326362481681721872150902208420539619641973896119680592696228972313317042316",
    "1636408035867347783699588740469182350452165486745277203525427807971352063169622066488977229506420856017031482691439089288020262006748233954177669740311",
    "1391860681743495586446518646883933051685658718352722633694285758474124803847473349064660555618847951719510263829699292297119131926436045214364252430665",
    "840450278810654165061961485691366961514650606247291814263792869596294713810125269780258316551932763106025157596216051681623225968811609560121609943365",
    "2329731862150094912355786583702878434766436140738594274867891494713002534085652731920888891507522355867974791619686673574928137376468103839586921126803",
    "3059472316627396548271906051517665887700234192652488639437431254697285170484189458770168152800520702020313091234437806236204196526193455750117363744648",
    "132216870748476988853044482759545262615616157934129470128771906579101230690441206392939162889560305016204867157725209170345968349185675785497832527174"
  };

  BigBinaryVector b3 = BBVfromStrvec(b3strvec);
  b3.SetModulus(q3);

  std::vector<std::string> modsum3strvec =
    {
      "732016832092609303033733946488851575508905224089926209249817078392018535656765998725014589313481039123037168472673687025432538609494741909227605490712",
      "1699342641679108265957658838484592424389901138210036584743655868072997162880915829271284796618161346407552961175240302978676734578936494043850964404405",
      "805268194532540254853221827315978332231079936014530430473277788624701006514735685778788450107791579012474778927303995844441006517704086579510924761862",
      "2309639787857591865810616858010749359723574390920875954217594558571830391533743872493637498240411933565079085036268433921366315257151622475294470987432",
      "1055195209860101268914836871873995113935083573879425166713353648336452849248093827352855861589603089346167525745353916089497326627735522601358120785649",
      "2079272278780507283826438187565711365662706106566241503594152379685216330309021278700545062992019577249504763265865102246737159166053065841450634441253",
      "1963961166839109935958630686427211631758268415664486282780692695470499499487186103469461604166903659582068706589022694543822554406981111684423535524192",
      "429450322550600283289891166311775461461030276309914725166992747749473739737643236568408402032463028150942488266038351241904353417501229826560720600164",
    };
  BigBinaryVector modsum3 = BBVfromStrvec(modsum3strvec);
  modsum3.SetModulus(q3);
  
  std::vector<std::string>  moddiff3strvec =
    {
      "512597535603578636284620600471706441361256218177317597892343972007351046282937957699448030289016340695226985347494856694864680738501332532337154369965",
      "1258144990936911203380326908782167797434418468585961447166768171869509300176263104307921352873859541990711881935956355186437373393544036099224330319773",
      "805842730693986557467234043205212783543391008567040812905713540778130676580166107684104083420854024129298497671985888277617739050093011724484112870671",
      "2799309032266742562930769261070482408568899000258495476312314409719714580243471729247586479328620187276945241504429920336345307950164925099894493715533",
      "2647685260134934808804103597318860343122424407427906327669059277239997218032517842675609320811641720285003894680481883735468131235997696534443428488350",
      "693199162376459329128054716987553648346475871132117743341660758355345058542390369742037372302879022664441864154051826106098140959002251215605319777078",
      "2391797749376600579441197977047078160791084122445638582872412922268196751328156295695665483217670569843215892375267224089848674446364986290845863213758",
      "165016581053646305583802200792684936229797960441655784909448934591271278356760823782530076253342418118532753950587932901212416719129878255565055545816",
    };
  BigBinaryVector moddiff3 = BBVfromStrvec(moddiff3strvec);
  moddiff3.SetModulus(q3);
  
  std::vector<std::string> modmul3strvec =
    { 
      "1031054745145843056820705945780914118282144310817341310210020640625431998591940403233545109350272933868060509405157360000389345101372898822036359679625",
      "39893990336327654775086201222472749396440031633689107793562292818341559091551650098949141027412374031231642492390533436782802979527602128674296589001",
      "1281575364673380787247887100773933340217543950815953588352031340354110014040347164387450177246143958852636145466379632479296531828035602618716943463922",
      "8876626876958332707488109358602242636976932642794865821404042110211562924605397999217054754859843534043902943791892973269404255881395585577402022234",
      "1216222886905600696846574145744495331189790230286057979942862366975568127231919204120976315097923349074161373380531458334894968146858459205019035261534",
      "753004725575957473234700352714317139479193934162886068369016394155680048439319699359431951178436867519868720662245420487511271148333130090416613227734",
      "2781700410947724700353568488987777429973246834920346616320143955645243949889536315043352628634199412806795883041065539549687937536501039961931401092055",
      "477574462920419903543345320561430691498452711801747910227743781056369739411065806345235440677935972019383967954633150768168291144898135169751571023658",
    };

  BigBinaryVector modmul3 = BBVfromStrvec(modmul3strvec);
  modmul3.SetModulus(q3);


  TESTIT(t3, c3, a3.ModAdd(b3), modsum3, nloop);
  TESTIT(t3, c3, a3.ModSub(b3), moddiff3, nloop);
  TESTIT(t3, c3, a3.ModMul(b3), modmul3, nloop);

  return;
}


//////////////////// helper functions fofr test_ubintvec()
//todo figure out how to share code between these vec_diffs

//function to compare two bintvecs and print differing indicies
void vec_diff(ubintvec &a, ubintvec &b) {
  for (usint i= 0; i < a.size(); ++i){  //todo change to size()
    if (a[i] != b[i]) {  //todo: add [] indexing to class
      cout << "i: "<< i << endl;
      cout << "first vector " <<endl;
      cout <<a[i];
      cout << endl;
      cout << "state " << a[i].GetState() << endl;;
      cout << "msb: " << a[i].GetMSB() << endl;;
      cout << "second vector " <<endl;
      cout << b[i];
      cout << endl;
      cout << "state " << b[i].GetState() << endl;;
      cout << "msb: " << b[i].GetMSB() << endl;;
      cout << endl;
    }
  }

}
//function to compare mubintvec with  bintvecs and print differing indicies
void vec_diff(mubintvec &a, ubintvec &b) {
    for (usint i= 0; i < a.size(); ++i){  //todo change to size()
      if (a[i] != b[i]) {  //todo: add [] indexing to class
        cout << "i: "<< i << endl;
	cout << "first vector " <<endl;
        cout << a[i];
        cout << endl;
        cout << "state " << a[i].GetState() << endl;;
        cout << "msb: " << a[i].GetMSB() << endl;;
	cout << "second vector " <<endl;
        cout << b[i];
        cout << endl;
        cout << "state " << b[i].GetState() << endl;;
        cout << "msb: " << b[i].GetMSB() << endl;;
        cout << endl;
      }
    }


}
//function to compare mubintvec with  bintvecs and print differing indicies
void vec_diff(mubintvec &a, mubintvec &b) {
    for (usint i= 0; i < a.size(); ++i){  //todo change to size()
      if (a[i] != b[i]) {  //todo: add [] indexing to class
        cout << "i: "<< i << endl;
	cout << "first vector " <<endl;
        cout << a[i];
        cout << endl;
        cout << "state " << a[i].GetState() << endl;;
        cout << "msb: " << a[i].GetMSB() << endl;;
	cout << "second vector " <<endl;
        cout << b[i];
        cout << endl;
        cout << "state " << b[i].GetState() << endl;;
        cout << "msb: " << b[i].GetMSB() << endl;;
        cout << endl;
      }
    }


}
// Code to test ubintvec at three different numbers of limbs.
void test_ubintvec() {

  int nloop = 1000; //number of times to run each test for timing.

  bool dbg_flag = 1;		// if true then print dbg output
 
  TimeVar t1,t2, t3,t_total; // timers for TIC() TOC()
  double time1;		    // captures the time in usec.
  double time2;
  double time3;
  double timeTotal;		// overal time

  cout<<"testing ubintvec"<<endl;
cout<<"todo test assignment, < >operators etc. not just math "<<endl;
  TIC(t_total);
  //there are three test cases, 1) small modulus 2) approx 48 bits. 3)
  //large numbers


  // q1 modulus 1:
  ubint q1("00000000000000163841");

  // a1:
  std::vector<std::string>  a1sv =

    { "00000000000000127753", "00000000000000077706",
      "00000000000000017133", "00000000000000022582",
      "00000000000000112132", "00000000000000027625",
      "00000000000000126773", "00000000000000008924",
      "00000000000000125972", "00000000000000002551",
      "00000000000000113837", "00000000000000112045",
      "00000000000000100953", "00000000000000077352",
      "00000000000000132013", "00000000000000057029", };

  ubintvec a1(a1sv);
  mubintvec ma1(a1sv,q1);

  // b1:
  std::vector<std::string>  b1sv = 
    {"00000000000000066773", "00000000000000069572",
     "00000000000000142134", "00000000000000141115",
     "00000000000000123182", "00000000000000155822",
     "00000000000000128147", "00000000000000094818",
     "00000000000000135782", "00000000000000030844",
     "00000000000000088634", "00000000000000099407",
     "00000000000000053647", "00000000000000111689",
     "00000000000000028502", "00000000000000026401", };

  ubintvec b1(b1sv);
  mubintvec mb1(b1sv,q1);

  // add1:
  std::vector<std::string>  add1sv = 
    {"00000000000000194526", "00000000000000147278",
     "00000000000000159267", "00000000000000163697",
     "00000000000000235314", "00000000000000183447",
     "00000000000000254920", "00000000000000103742",
     "00000000000000261754", "00000000000000033395",
     "00000000000000202471", "00000000000000211452",
     "00000000000000154600", "00000000000000189041",
     "00000000000000160515", "00000000000000083430", };

  ubintvec add1(add1sv);

  // sub1:
#if 0 //set to 1 if we allow b>a in subtraction
  std::vector<std::string>  sub1sv = 
    {"00000000000000060980", "00000000000000008134",
     "18446744073709426615", "18446744073709433083",
     "18446744073709540566", "18446744073709423419",
     "18446744073709550242", "18446744073709465722",
     "18446744073709541806", "18446744073709523323",
     "00000000000000025203", "00000000000000012638",
     "00000000000000047306", "18446744073709517279",
     "00000000000000103511", "00000000000000030628", };

#else
  std::vector<std::string> sub1sv = 

    {"00000000000000060980", "00000000000000008134",
     "00000000000000000000", "00000000000000000000",
     "00000000000000000000", "00000000000000000000",
     "00000000000000000000", "00000000000000000000",
     "00000000000000000000", "00000000000000000000",
     "00000000000000025203", "00000000000000012638",
     "00000000000000047306", "00000000000000000000",
     "00000000000000103511", "00000000000000030628", };
#endif
  ubintvec sub1(sub1sv);

  // mul1:
  std::vector<std::string>  mul1sv = 
    {"000000000000000000000000000008530451069",
     "000000000000000000000000000005406161832",
     "000000000000000000000000000002435181822",
     "000000000000000000000000000003186658930",
     "000000000000000000000000000013812644024",
     "000000000000000000000000000004304582750",
     "000000000000000000000000000016245579631",
     "000000000000000000000000000000846155832",
     "000000000000000000000000000017104730104",
     "000000000000000000000000000000078683044",
     "000000000000000000000000000010089828658",
     "000000000000000000000000000011138057315",
     "000000000000000000000000000005415825591",
     "000000000000000000000000000008639367528",
     "000000000000000000000000000003762634526",
     "000000000000000000000000000001505622629", };
  ubintvec mul1(mul1sv);

  // modadd1:
  std::vector<std::string>  modadd1sv = 
    {"00000000000000030685", "00000000000000147278",
     "00000000000000159267", "00000000000000163697",
     "00000000000000071473", "00000000000000019606",
     "00000000000000091079", "00000000000000103742",
     "00000000000000097913", "00000000000000033395",
     "00000000000000038630", "00000000000000047611",
     "00000000000000154600", "00000000000000025200",
     "00000000000000160515", "00000000000000083430", };
  ubintvec modadd1(modadd1sv);

  // modsub1:
  std::vector<std::string>  modsub1sv = 
    {"00000000000000060980", "00000000000000008134",
     "00000000000000038840", "00000000000000045308",
     "00000000000000152791", "00000000000000035644",
     "00000000000000162467", "00000000000000077947",
     "00000000000000154031", "00000000000000135548",
     "00000000000000025203", "00000000000000012638",
     "00000000000000047306", "00000000000000129504",
     "00000000000000103511", "00000000000000030628", };
  ubintvec modsub1(modsub1sv);

  // modmul1:
  std::vector<std::string>  modmul1sv = 
    {"00000000000000069404", "00000000000000064196",
     "00000000000000013039", "00000000000000115321",
     "00000000000000028519", "00000000000000151998",
     "00000000000000089117", "00000000000000080908",
     "00000000000000057386", "00000000000000039364",
     "00000000000000008355", "00000000000000146135",
     "00000000000000061336", "00000000000000031598",
     "00000000000000025961", "00000000000000087680", };
  ubintvec modmul1(modmul1sv);

  ubintvec c1;
  mubintvec mc1;
  // test math for case 1
  TESTIT(t1, c1, a1 + b1, add1, nloop);
  TESTIT(t1, c1, a1 - b1, sub1, nloop);
  TESTIT(t1, c1, a1 * b1, mul1, nloop);
  TESTIT(t1, c1, a1.ModAdd(b1,q1), modadd1, nloop);
  TESTIT(t1, mc1, ma1 + mb1,  modadd1, nloop);
  TESTIT(t1, c1, a1.ModSub(b1,q1), modsub1, nloop);
  TESTIT(t1, mc1, ma1 - mb1,  modsub1, nloop);
  TESTIT(t1, c1, a1.ModMul(b1,q1), modmul1, nloop);
  TESTIT(t1, mc1, ma1 * mb1,  modmul1, nloop);
  TESTIT(t1, mc1, ma1.BModMul(mb1),  modmul1, nloop);

  // q2: larger numbers

  ubint q2("00004057816419532801");
  //cout << "q2 contents"<<endl;
  //q2.PrintLimbsInDec();

  // a2:
  std::vector<std::string>  a2sv = 
    {"00000185225172798255", "00000098879665709163",
     "00003497410031351258", "00004012431933509255",
     "00001543020758028581", "00000135094568432141",
     "00003976954337141739", "00004030348521557120",
     "00000175940803531155", "00000435236277692967",
     "00003304652649070144", "00002032520019613814",
     "00000375749152798379", "00003933203511673255",
     "00002293434116159938", "00001201413067178193", };
  ubintvec a2(a2sv);
  mubintvec ma2(a2sv,q2);


  // b2:
  std::vector<std::string>  b2sv = 
    {"00000698898215124963", "00000039832572186149",
     "00001835473200214782", "00001041547470449968",
     "00001076152419903743", "00000433588874877196",
     "00002336100673132075", "00002990190360138614",
     "00000754647536064726", "00000702097990733190",
     "00002102063768035483", "00000119786389165930",
     "00003976652902630043", "00003238750424196678",
     "00002978742255253796", "00002124827461185795", };

  ubintvec b2(b2sv);
  mubintvec mb2(b2sv,q2);
  // add2:
  std::vector<std::string>  add2sv = 
    {"00000884123387923218", "00000138712237895312",
     "00005332883231566040", "00005053979403959223",
     "00002619173177932324", "00000568683443309337",
     "00006313055010273814", "00007020538881695734",
     "00000930588339595881", "00001137334268426157",
     "00005406716417105627", "00002152306408779744",
     "00004352402055428422", "00007171953935869933",
     "00005272176371413734", "00003326240528363988", };
  ubintvec add2(add2sv);
  // sub2:
#if 0 //set to 1 if we allow b>a in subtraction
  std::vector<std::string>  sub2sv = 
    {"18446230400667224908", "00000059047093523014",
     "00001661936831136476", "00002970884463059287",
     "00000466868338124838", "18446445579403106561",
     "00001640853664009664", "00001040158161418506",
     "18446165366977018045", "18446477211996511393",
     "00001202588881034661", "00001912733630447884",
     "18443143169959719952", "00000694453087476577",
     "18446058765570457758", "18445820659315544014", };

#else
  std::vector<std::string>  sub2sv = 
    {"00000000000000000000", "00000059047093523014",
     "00001661936831136476", "00002970884463059287",
     "00000466868338124838", "00000000000000000000",
     "00001640853664009664", "00001040158161418506",
     "00000000000000000000", "00000000000000000000",
     "00001202588881034661", "00001912733630447884",
     "00000000000000000000", "00000694453087476577",
     "00000000000000000000", "00000000000000000000", };

#endif
  ubintvec sub2(sub2sv);

  // mul2:
  std::vector<std::string>  mul2sv = 
    {"000000000129453542664913267883213339565",
     "000000000003938631422102517149330983287",
     "000000006419402382707574566639285895756",
     "000000004179138330699238739092142453840",
     "000000001660525522714165323210462878683",
     "000000000058575501928512376649634356636",
     "000000009290565704012341618368342178425",
     "000000012051509297159015143330318631680",
     "000000000132773293878034164433437538530",
     "000000000305578516062424854278036474730",
     "000000006946590599552827582889547919552",
     "000000000243468234057004000432166157020",
     "000000001494223959136453394722407100297",
     "000000012738664541883618180978992446890",
     "000000006831549111446250063725117624648",
     "000000002552795477367678807574345368435", };
  ubintvec mul2(mul2sv);

  // modadd2:
  std::vector<std::string>  modadd2sv = 
    {"00000884123387923218", "00000138712237895312",
     "00001275066812033239", "00000996162984426422",
     "00002619173177932324", "00000568683443309337",
     "00002255238590741013", "00002962722462162933",
     "00000930588339595881", "00001137334268426157",
     "00001348899997572826", "00002152306408779744",
     "00000294585635895621", "00003114137516337132",
     "00001214359951880933", "00003326240528363988", };
  ubintvec modadd2(modadd2sv);

  // modsub2:
  std::vector<std::string>  modsub2sv = 
    {"00003544143377206093", "00000059047093523014",
     "00001661936831136476", "00002970884463059287",
     "00000466868338124838", "00003759322113087746",
     "00001640853664009664", "00001040158161418506",
     "00003479109686999230", "00003790954706492578",
     "00001202588881034661", "00001912733630447884",
     "00000456912669701137", "00000694453087476577",
     "00003372508280438943", "00003134402025525199", };
  ubintvec modsub2(modsub2sv);

  // modmul2:
  std::vector<std::string>  modmul2sv = 
    {"00000585473140075497", "00003637571624495703",
     "00001216097920193708", "00001363577444007558",
     "00000694070384788800", "00002378590980295187",
     "00000903406520872185", "00000559510929662332",
     "00000322863634303789", "00001685429502680940",
     "00001715852907773825", "00002521152917532260",
     "00000781959737898673", "00002334258943108700",
     "00002573793300043944", "00001273980645866111", };
  ubintvec modmul2(modmul2sv);

  ubintvec c2;
  mubintvec mc2;
  // test math for case 2
  TESTIT(t2, c2, a2 + b2, add2, nloop);
  TESTIT(t2, c2, a2 - b2, sub2, nloop);
  TESTIT(t2, c2, a2 * b2, mul2, nloop);
  TESTIT(t2, c2, a2.ModAdd(b2,q2), modadd2, nloop);
  TESTIT(t2, mc2, ma2 + mb2, modadd2, nloop); 
  TESTIT(t2, c2, a2.ModSub(b2,q2), modsub2, nloop);
  TESTIT(t2, mc2, ma2 - mb2, modsub2, nloop);
  TESTIT(t2, c2, a2.ModMul(b2,q2), modmul2, nloop);
  TESTIT(t2, mc2, ma2 * mb2,  modmul2, nloop);
  TESTIT(t2, mc2, ma2.BModMul(mb2),  modmul2, nloop);



  //q3: very large numbers.
  ubint q3("3273390607896141870013189696827599152216642046043064789483291368096133796404674554883270092325904157150886684127560071009217256545885393053328527589431");

  ubintvec a3;
  a3 = { 
    "2259002487796164904665772121894078584543401744155154298312726209247751689172189255653866355964200768484575418973864307364757237946940733747446643725054",
    "1478743816308009734668992873633380110912159803397999015955212019971253231528589466789603074746010444199132421555598329082557053986240265071537647362089",
    "2442250766561334341166822783674395133995556495312318016431141348749482739749788174173081312927274880146329980363424977565638001056841245678661782610982",
    "917779106114096279364098211126816308037915672568153320523308800097705587686270523428976942621563981845568821206569141624247183330715577260930218556767",
    "214744931049447103852875386182628152420432967632133352449560778740158135437968557572597545037670326240142368149137864407874100658923913041236510842284",
    "3022931024526554241483841300690432083112912011870712018209552253068347592628043101662926263810401378532416655773738499681026278335470355055192240903881",
    "2177879458107855257699914331737144896274676269055062432826552808869348125407671199582563543692287114712642299482144959316835614426673048987634699368975",
    "297233451802123294436846683552230198845414118375785255038220841170372509047202030175469239142902723134737621108313142071558385068315554041062888072990"};
  mubintvec ma3(a3,q3);
  
  mubintvec b3;
  b3 = {
    "1746404952192586268381151521422372143182145525977836700420382237240400642889251297954418325675184427789348433626369450669892557208439401215109489355089",
    "220598825371098531288665964851212313477741334812037568788443848101743931352326362481681721872150902208420539619641973896119680592696228972313317042316",
    "1636408035867347783699588740469182350452165486745277203525427807971352063169622066488977229506420856017031482691439089288020262006748233954177669740311",
    "1391860681743495586446518646883933051685658718352722633694285758474124803847473349064660555618847951719510263829699292297119131926436045214364252430665",
    "840450278810654165061961485691366961514650606247291814263792869596294713810125269780258316551932763106025157596216051681623225968811609560121609943365",
    "2329731862150094912355786583702878434766436140738594274867891494713002534085652731920888891507522355867974791619686673574928137376468103839586921126803",
    "3059472316627396548271906051517665887700234192652488639437431254697285170484189458770168152800520702020313091234437806236204196526193455750117363744648",
    "132216870748476988853044482759545262615616157934129470128771906579101230690441206392939162889560305016204867157725209170345968349185675785497832527174"};
  mubintvec mb3(b3,q3);


  ubintvec add3;
  add3 = {
    "4005407439988751173046923643316450727725547270132990998733108446488152332061440553608284681639385196273923852600233758034649795155380134962556133080143",
    "1699342641679108265957658838484592424389901138210036584743655868072997162880915829271284796618161346407552961175240302978676734578936494043850964404405",
    "4078658802428682124866411524143577484447721982057595219956569156720834802919410240662058542433695736163361463054864066853658263063589479632839452351293",
    "2309639787857591865810616858010749359723574390920875954217594558571830391533743872493637498240411933565079085036268433921366315257151622475294470987432",
    "1055195209860101268914836871873995113935083573879425166713353648336452849248093827352855861589603089346167525745353916089497326627735522601358120785649",
    "5352662886676649153839627884393310517879348152609306293077443747781350126713695833583815155317923734400391447393425173255954415711938458894779162030684",
    "5237351774735251805971820383254810783974910461707551072263984063566633295891860658352731696492807816732955390716582765553039810952866504737752063113623",
    "429450322550600283289891166311775461461030276309914725166992747749473739737643236568408402032463028150942488266038351241904353417501229826560720600164",
  };

  ubintvec sub3;
#if 0 // if a <b != 0
  sub3 = {

    "512597535603578636284620600471706441361256218177317597892343972007351046282937957699448030289016340695226985347494856694864680738501332532337154369965",
    "1258144990936911203380326908782167797434418468585961447166768171869509300176263104307921352873859541990711881935956355186437373393544036099224330319773",
    "805842730693986557467234043205212783543391008567040812905713540778130676580166107684104083420854024129298497671985888277617739050093011724484112870671",
    "-474081575629399307082420435757116743647743045784569313170976958376419216161202825635683612997283969873941442623130150672871948595720467953434033873898",
    "-625705347761207061209086099508738809094217638615158461814232090856136578372156712207660771514262436865882789447078187273749125309887696518885099101081",
    "693199162376459329128054716987553648346475871132117743341660758355345058542390369742037372302879022664441864154051826106098140959002251215605319777078",
    "-881592858519541290571991719780520991425557923597426206610878445827937045076518259187604609108233587307670791752292846919368582099520406762482664375673",
    "165016581053646305583802200792684936229797960441655784909448934591271278356760823782530076253342418118532753950587932901212416719129878255565055545816",
  };
#else
  sub3 = {
    "512597535603578636284620600471706441361256218177317597892343972007351046282937957699448030289016340695226985347494856694864680738501332532337154369965",
    "1258144990936911203380326908782167797434418468585961447166768171869509300176263104307921352873859541990711881935956355186437373393544036099224330319773",
    "805842730693986557467234043205212783543391008567040812905713540778130676580166107684104083420854024129298497671985888277617739050093011724484112870671",
    "0",
    "0",
    "693199162376459329128054716987553648346475871132117743341660758355345058542390369742037372302879022664441864154051826106098140959002251215605319777078",
    "0",
    "165016581053646305583802200792684936229797960441655784909448934591271278356760823782530076253342418118532753950587932901212416719129878255565055545816",
  };

#endif

  ubintvec mul3;
  mul3 = {
    "3945133131702594815505313517401955213422212906003207160550224827247798380158544728883063176021386698520393904638342934533842147122672165690895381911371610821805521968761803943619144153796694548166886289821562857014841953651542530764805091829231222294952980980415012824805935628205244762503711091699806",
    "326209148902322443940640858428575655800462302664603787971446127213213943734156672029644165209545417568093927431571229737889388146825783637352297738793838379605489067990018974600686396516030634863264832676726271905502450934842280843356017145798689170307553117850929852381350172055754068242724987158124",
    "3996518780004157625822415090647195375113582969537197325148397412987198668923299617655210998096768023432082550758182396647942738526222744503727730011083759641549078217904703406652423388993758005327181681934139933811259379898260107828051593334782557076645183323051795081283059651277095553321507476695402",
    "1277420652325902025823941663776494108926907091298812026686913886255674556691423716926727654799242553261895325995328828781861742245816072709575972687084748197171401854637034395082914459549271628438335228941663439445078782967098628431321726541159959431168664395766811100936463603966672711390068034060055",
    "180482437173682522960622020074582069971312997254639094063163947161104892043282487992242731589845620793992570111151202501208695820304854653522742492363941014162204782359669275314022851900215535563463499305020501669842254296096007609248733286624445014836059554190198244087213898342303628140365687245660",
    "7042618724921543448640048538894511085292095571328770917692070389597411133134433816609162364316153062666473265645864944271040483942778852526551730898067321099186001336307471882872329470753794993395722072009141582152086557176991299394829487910282094077082362155957220820918292438371443386247463735822443",
    "6663161911032458957637091338021552428846954075003065194738662366725753407230661950428910863564465232331799241680463789414149597794741173506193627020975596905904768316492860476695706055515048793725930388147468496386353338682120062327205347835675397402217405736179640771952939314867939122494628633495800",
    "39299276879045000335778052745261012743983854821402827577095882287055142208918031875556030922752660239994854929566549812623040336147884733019208891176315622960662348446192621970759838878368953344844095066240968924128522243769943119204473694089774742680964827784964421418174674383861285589714670430260",
  };


  mubintvec modadd3;
  modadd3.SetModulus(q3);
  modadd3 = {
    "732016832092609303033733946488851575508905224089926209249817078392018535656765998725014589313481039123037168472673687025432538609494741909227605490712",
    "1699342641679108265957658838484592424389901138210036584743655868072997162880915829271284796618161346407552961175240302978676734578936494043850964404405",
    "805268194532540254853221827315978332231079936014530430473277788624701006514735685778788450107791579012474778927303995844441006517704086579510924761862",
    "2309639787857591865810616858010749359723574390920875954217594558571830391533743872493637498240411933565079085036268433921366315257151622475294470987432",
    "1055195209860101268914836871873995113935083573879425166713353648336452849248093827352855861589603089346167525745353916089497326627735522601358120785649",
    "2079272278780507283826438187565711365662706106566241503594152379685216330309021278700545062992019577249504763265865102246737159166053065841450634441253",
    "1963961166839109935958630686427211631758268415664486282780692695470499499487186103469461604166903659582068706589022694543822554406981111684423535524192",
    "429450322550600283289891166311775461461030276309914725166992747749473739737643236568408402032463028150942488266038351241904353417501229826560720600164",
  };

  mubintvec modsub3;
  modsub3.SetModulus(q3);
  modsub3 = {
    "512597535603578636284620600471706441361256218177317597892343972007351046282937957699448030289016340695226985347494856694864680738501332532337154369965",
    "1258144990936911203380326908782167797434418468585961447166768171869509300176263104307921352873859541990711881935956355186437373393544036099224330319773",
    "805842730693986557467234043205212783543391008567040812905713540778130676580166107684104083420854024129298497671985888277617739050093011724484112870671",
    "2799309032266742562930769261070482408568899000258495476312314409719714580243471729247586479328620187276945241504429920336345307950164925099894493715533",
    "2647685260134934808804103597318860343122424407427906327669059277239997218032517842675609320811641720285003894680481883735468131235997696534443428488350",
    "693199162376459329128054716987553648346475871132117743341660758355345058542390369742037372302879022664441864154051826106098140959002251215605319777078",
    "2391797749376600579441197977047078160791084122445638582872412922268196751328156295695665483217670569843215892375267224089848674446364986290845863213758",
    "165016581053646305583802200792684936229797960441655784909448934591271278356760823782530076253342418118532753950587932901212416719129878255565055545816",
  };

  mubintvec modmul3;
  modmul3.SetModulus(q3);
    modmul3 = {
    "1031054745145843056820705945780914118282144310817341310210020640625431998591940403233545109350272933868060509405157360000389345101372898822036359679625",
    "39893990336327654775086201222472749396440031633689107793562292818341559091551650098949141027412374031231642492390533436782802979527602128674296589001",
    "1281575364673380787247887100773933340217543950815953588352031340354110014040347164387450177246143958852636145466379632479296531828035602618716943463922",
    "8876626876958332707488109358602242636976932642794865821404042110211562924605397999217054754859843534043902943791892973269404255881395585577402022234",
    "1216222886905600696846574145744495331189790230286057979942862366975568127231919204120976315097923349074161373380531458334894968146858459205019035261534",
    "753004725575957473234700352714317139479193934162886068369016394155680048439319699359431951178436867519868720662245420487511271148333130090416613227734",
    "2781700410947724700353568488987777429973246834920346616320143955645243949889536315043352628634199412806795883041065539549687937536501039961931401092055",
    "477574462920419903543345320561430691498452711801747910227743781056369739411065806345235440677935972019383967954633150768168291144898135169751571023658",
  };

  ubintvec c3;
  mubintvec mc3;
  // test math for case 3
  TESTIT(t3, c3, a3 + b3, add3, nloop);
  TESTIT(t3, c3, a3 - b3, sub3, nloop);
  TESTIT(t3, c3, a3 * b3, mul3, nloop);
  TESTIT(t3, c3, a3.ModAdd(b3,q3), modadd3, nloop);
  TESTIT(t3, mc3, ma3 + mb3, modadd3, nloop); 
  TESTIT(t3, c3, a3.ModSub(b3,q3), modsub3, nloop);
  TESTIT(t3, mc3, ma3 - mb3, modsub3, nloop);
  TESTIT(t3, c3, a3.ModMul(b3,q3), modmul3, nloop);
  TESTIT(t3, mc3, ma3 * mb3,  modmul3, nloop);
  TESTIT(t3, mc3, ma3.BModMul(mb3),  modmul3, nloop);



  return ;
}


typedef
struct
{
  usint w;  
  usint n;
  usint nw;
  usint r;
  usint shift1;
  usint shift2;
}BarrettMWParamStruct;


ubint init_barrett_mod_mul(usint w, usint MNumBits, ubint &M, BarrettMWParamStruct &BP) {

  // w is the number of bits of the radix (word size)
  // MNumBits is the number of bits that represent M (i.e. our largest bitwidth...
  //   note this is not the bitwidth of the underlying integer, but rather the size of the smallest
  //   number of bits that represent M
  // M is our Modulus
  // this code sets us up for limb_t radix.

  bool  dbg_flag = false; // if true print debug statements

  usint n = MNumBits;

  BP.w = w;
  BP.n = n;
  // nw is the number of words (each of radix r) needed
  BP.nw = (usint) ceil((float)n/(float)w);
  // r is the radix
  BP.r = (usint)pow(2.0,(float)w);
  DEBUG("w "<< w << " n "<< n << " nw "<< BP.nw);

  // alpha and beta are used to compute the shifts needed
  sint alpha = w+3;
  sint beta = -2;

  DEBUG("alpha "<< alpha << " beta "<<beta );

  BP.shift1 = n+beta;
  //BP.fast_div1 = 2^(n+beta);
  BP.shift2 = alpha-beta;
  //BP.fast_div2 =  2^(alpha-beta);


  // tmp = fi(0,0,n+alpha+1,0);
  // tmp = bitset(tmp,n+alpha+1);

  // if 1
  //     %BP.mu = floor(fi((2^(n+alpha))/fi(M)));
  //     wordLength = tmp.WordLength;
  //     fracLength = MNumBits;
  //     nt_scale = numerictype(signed,wordLength,fracLength);
  //     tmp2 = nt_scale.divide(tmp,M);
  //     tmp3 = fi(tmp2, 'WordLength', wordLength-fracLength, 'FractionLength', 0);
  //     BP.mu = tmp3;
  // end


  //else
  ubint two (ubint::TWO);
  ubint tmp = two.Exp(n+alpha);
  DEBUG( "powtest "<<pow(2,(n+alpha)) );
  DEBUG("tmp in hex is: "); if (dbg_flag) tmp.PrintLimbsInHex();

  //BP.mu = floor((2^(n+alpha)/M));
  ubint mu (tmp/M); //integer divide

  //end

  DEBUG("barrett constants for M  = "<< M <<" radix = "<< BP.r);
  DEBUG(" d = 2^"<< w << " mu = "<< mu);

  DEBUG("num bits = "<< BP.n << " num words = "<<BP.nw);
  DEBUG("r mul = "<< w <<" bits, shift 1 = "<< BP.shift1 <<" bits, shift 2 = "<< BP.shift2 <<" bits");

  return(mu);

}


ubint &BMM(ubint &x, ubint &y, ubint &M, ubint &mu, BarrettMWParamStruct &BP) {
  // Perform barrett form of modulo multiprecision multiplication double and
  //  fi version. (note fi inputs calls barrett_mod_mul_fi_vxx.m
  // from:
  // Faster Interleaved Modular Multiplication Based on Barrett and
  // Montgomery Reduction Methods
  // Miroslav Kne!zevi"c, Member, IEEE,
  // Frederik Vercauteren, and
  // Ingrid Verbauwhede, Senior Member, IEEE
  // adapted for Palisade by  Dave Cousins BBN (c) 2016
  // inputs are x and y, Barret Parameters are BP.


  // Example:  hex radix. or 4 bit digits. so r = 16 = 2^4, and w = 4;
  // so M can be represented in nw = 3 digits: 7 0 9
  // this code sets us up for limb_t radix.

  //  ubint x = *this;

  //global count1 count2 // for statistics

  bool  dbg_flag = false; // if true print debug statements

  if (dbg_flag) {
    DEBUG("x in hex is: ");
    x.PrintLimbsInHex();
    DEBUG("");
    DEBUG("y in hex is: ");
    y.PrintLimbsInHex();
    DEBUG("");
  }

  // decompose y into digits of radix r
  ubint ytmp(y);
  usint yNumLimbs(y.GetNumberOfLimbs());
  ubintvec ydigits(yNumLimbs);

  for (usint ix = 0; ix < yNumLimbs; ix++) {
      ydigits[ix] = y.m_value.at(ix); // break into digits.
  }
    /* for (usint ix = 0; ix < BP.nw; ix++) { */
    /*   ydigits(ix) = mod(ytmp,BP.r); */
    /*   ytmp = ytmp - ydigits(ix); */
    /*   ytmp = ytmp/BP.r; */
    /*   if (dbgflag) */
    /*     fprintf('digit %d %s \n',ix, dec2hex(ydigits(ix))); */

  // //  this is the actual reduction
  ubint zed("0");
  ubint t1("0");
  ubint t2("0");
  ubint t3("0");
  ubint t4("0");
  ubint t5("0");
  // for ix = BP.nw:-1:1
  for( sint ix = ydigits.size()-1; ix>= 0; ix-- ){
    //  *r is a shift left, r is 2^w
    //t1 = z * BP.r;
    t1 = zed<< BP.w;
    t2 = x * ydigits[ix];
    t3 = t1 + t2;

    zed = t3;
    if (dbg_flag) {
      cout<< "ix "<<ix <<endl;
      cout<< "t1 "; t1.PrintLimbsInHex();
      cout<< "t2 "; t2.PrintLimbsInHex();
      cout<< "t3 "; t3.PrintLimbsInHex();
      cout<< "z  "; zed.PrintLimbsInHex();
    }
    // z = z.*BP.r + x .* ydigits(ix);
    // q = floor(z./M);

    //ubint t4 = floor(z/BP.fast_div1);
    t4 = zed>>BP.shift1;
    t5 = t4 * mu;
    if (dbg_flag){
      cout<<"t4 "; t4.PrintLimbsInHex();
      cout<<"t5 "; t5.PrintLimbsInHex();
    }

    //ubint qprime = floor(t5/BP.fast_div2);
    ubint qprime = t5>>BP.shift2;
    // qprime = floor((floor(z/BP.fast_div1) .* BP.mu)/BP.fast_div2);

    // z = z -q.*M;
    zed = zed - qprime * M;
    if (dbg_flag) {
      cout<<"qrime "; qprime.PrintLimbsInHex();
      cout<<"z ";zed.PrintLimbsInHex();
    }
  }

  // now we need to test z
  if (zed>= M) {
    zed = zed-M;
    if (dbg_flag) {
      cout<<"z-M "; zed.PrintLimbsInHex();
    }
    //count1 = count1 + 1;
  }
  if (0) {
    // not sure if this is ever used.
    while (zed < ubint::ZERO) {
      zed = zed + M;
      //    count2 = count2 + 1;
    }
  }

  return(zed);

}


 void test_BMM() {

  bool dbg_flag = 1;		// if true then print dbg output
 
  cout<<"testing BMM"<<endl;

  //there are three test cases, 1) small modulus 2) approx 48 bits. 3)
  //large numbers


  // q1 modulus 1:
  ubint q1("00000000000000163841");

   // a1:
   std::vector<std::string>  a1sv =

     { "00000000000000127753", "00000000000000077706",
       "00000000000000017133", "00000000000000022582",
       "00000000000000112132", "00000000000000027625",
       "00000000000000126773", "00000000000000008924",
       "00000000000000125972", "00000000000000002551",
       "00000000000000113837", "00000000000000112045",
       "00000000000000100953", "00000000000000077352",
       "00000000000000132013", "00000000000000057029", };

   ubintvec a1(a1sv);

   b1:
   std::vector<std::string>  b1sv = 
     {"00000000000000066773", "00000000000000069572",
      "00000000000000142134", "00000000000000141115",
      "00000000000000123182", "00000000000000155822",
      "00000000000000128147", "00000000000000094818",
      "00000000000000135782", "00000000000000030844",
      "00000000000000088634", "00000000000000099407",
      "00000000000000053647", "00000000000000111689",
      "00000000000000028502", "00000000000000026401", };

   ubintvec b1(b1sv);

  // modmul1:
  std::vector<std::string>  modmul1sv = 
    {"00000000000000069404", "00000000000000064196",
     "00000000000000013039", "00000000000000115321",
     "00000000000000028519", "00000000000000151998",
     "00000000000000089117", "00000000000000080908",
     "00000000000000057386", "00000000000000039364",
     "00000000000000008355", "00000000000000146135",
     "00000000000000061336", "00000000000000031598",
     "00000000000000025961", "00000000000000087680", };
  ubintvec modmul1(modmul1sv);

  ubintvec c1(b1.size());

  // test math for case 1

  BarrettMWParamStruct BP;
  ubint mu("0");
  mu = init_barrett_mod_mul(sizeof(usint)*8, q1.GetMSB()-1, q1, BP); //modifies BP

  //todo make limb_t
  for (auto i = 0; i < a1.size(); i++){
    c1[i] = BMM(a1[i], b1[i], q1, mu, BP);
  }
  if (c1 != modmul1){
    cout <<"FAIL BMM"<<endl;
    vec_diff(c1, modmul1);\
  } else {
    cout<< "BMM PASSED"<<endl;
  }
  

  // q2: larger numbers

  ubint q2("00004057816419532801");
  //cout << "q2 contents"<<endl;
  //q2.PrintLimbsInDec();

  // a2:
  std::vector<std::string>  a2sv = 
    {"00000185225172798255", "00000098879665709163",
     "00003497410031351258", "00004012431933509255",
     "00001543020758028581", "00000135094568432141",
     "00003976954337141739", "00004030348521557120",
     "00000175940803531155", "00000435236277692967",
     "00003304652649070144", "00002032520019613814",
     "00000375749152798379", "00003933203511673255",
     "00002293434116159938", "00001201413067178193", };
  ubintvec a2(a2sv);

  // b2:
  std::vector<std::string>  b2sv = 
    {"00000698898215124963", "00000039832572186149",
     "00001835473200214782", "00001041547470449968",
     "00001076152419903743", "00000433588874877196",
     "00002336100673132075", "00002990190360138614",
     "00000754647536064726", "00000702097990733190",
     "00002102063768035483", "00000119786389165930",
     "00003976652902630043", "00003238750424196678",
     "00002978742255253796", "00002124827461185795", };

  ubintvec b2(b2sv);

  // modmul2:
  std::vector<std::string>  modmul2sv = 
    {"00000585473140075497", "00003637571624495703",
     "00001216097920193708", "00001363577444007558",
     "00000694070384788800", "00002378590980295187",
     "00000903406520872185", "00000559510929662332",
     "00000322863634303789", "00001685429502680940",
     "00001715852907773825", "00002521152917532260",
     "00000781959737898673", "00002334258943108700",
     "00002573793300043944", "00001273980645866111", };
  ubintvec modmul2(modmul2sv);

  ubintvec c2(b2.size());

  mu = init_barrett_mod_mul(sizeof(usint)*8, q2.GetMSB()-1, q2, BP); //modifies BP

  //todo make limb_t
   for (auto i = 0; i < a2.size(); i++){
    c2[i] = BMM(a2[i], b2[i], q2, mu, BP);
  }
  if (c2 != modmul2){
    cout <<"FAIL BMM 2"<<endl;
    vec_diff(c2, modmul2);\
  } else {
    cout<< "BMM 2 PASSED"<<endl;
  }
  


  //q3: very large numbers.
  ubint q3("3273390607896141870013189696827599152216642046043064789483291368096133796404674554883270092325904157150886684127560071009217256545885393053328527589431");

  ubintvec a3;
  a3 = { 
    "2259002487796164904665772121894078584543401744155154298312726209247751689172189255653866355964200768484575418973864307364757237946940733747446643725054",
    "1478743816308009734668992873633380110912159803397999015955212019971253231528589466789603074746010444199132421555598329082557053986240265071537647362089",
    "2442250766561334341166822783674395133995556495312318016431141348749482739749788174173081312927274880146329980363424977565638001056841245678661782610982",
    "917779106114096279364098211126816308037915672568153320523308800097705587686270523428976942621563981845568821206569141624247183330715577260930218556767",
    "214744931049447103852875386182628152420432967632133352449560778740158135437968557572597545037670326240142368149137864407874100658923913041236510842284",
    "3022931024526554241483841300690432083112912011870712018209552253068347592628043101662926263810401378532416655773738499681026278335470355055192240903881",
    "2177879458107855257699914331737144896274676269055062432826552808869348125407671199582563543692287114712642299482144959316835614426673048987634699368975",
    "297233451802123294436846683552230198845414118375785255038220841170372509047202030175469239142902723134737621108313142071558385068315554041062888072990"};
  
  ubintvec b3;
  b3 = {
    "1746404952192586268381151521422372143182145525977836700420382237240400642889251297954418325675184427789348433626369450669892557208439401215109489355089",
    "220598825371098531288665964851212313477741334812037568788443848101743931352326362481681721872150902208420539619641973896119680592696228972313317042316",
    "1636408035867347783699588740469182350452165486745277203525427807971352063169622066488977229506420856017031482691439089288020262006748233954177669740311",
    "1391860681743495586446518646883933051685658718352722633694285758474124803847473349064660555618847951719510263829699292297119131926436045214364252430665",
    "840450278810654165061961485691366961514650606247291814263792869596294713810125269780258316551932763106025157596216051681623225968811609560121609943365",
    "2329731862150094912355786583702878434766436140738594274867891494713002534085652731920888891507522355867974791619686673574928137376468103839586921126803",
    "3059472316627396548271906051517665887700234192652488639437431254697285170484189458770168152800520702020313091234437806236204196526193455750117363744648",
    "132216870748476988853044482759545262615616157934129470128771906579101230690441206392939162889560305016204867157725209170345968349185675785497832527174"};


  ubintvec modmul3;
  modmul3 = {
    "1031054745145843056820705945780914118282144310817341310210020640625431998591940403233545109350272933868060509405157360000389345101372898822036359679625",
    "39893990336327654775086201222472749396440031633689107793562292818341559091551650098949141027412374031231642492390533436782802979527602128674296589001",
    "1281575364673380787247887100773933340217543950815953588352031340354110014040347164387450177246143958852636145466379632479296531828035602618716943463922",
    "8876626876958332707488109358602242636976932642794865821404042110211562924605397999217054754859843534043902943791892973269404255881395585577402022234",
    "1216222886905600696846574145744495331189790230286057979942862366975568127231919204120976315097923349074161373380531458334894968146858459205019035261534",
    "753004725575957473234700352714317139479193934162886068369016394155680048439319699359431951178436867519868720662245420487511271148333130090416613227734",
    "2781700410947724700353568488987777429973246834920346616320143955645243949889536315043352628634199412806795883041065539549687937536501039961931401092055",
    "477574462920419903543345320561430691498452711801747910227743781056369739411065806345235440677935972019383967954633150768168291144898135169751571023658",
  };

  ubintvec c3(b3.size());

  mu = init_barrett_mod_mul(sizeof(usint)*8, q3.GetMSB()-1, q3, BP); //modifies BP

  //todo make limb_t
   for (auto i = 0; i < a3.size(); i++){
    c3[i] = BMM(a3[i], b3[i], q3, mu, BP);
  }
  if (c3 != modmul3){
    cout <<"FAIL BMM 3"<<endl;
    vec_diff(c3, modmul3);\
  } else {
    cout<< "BMM 3 PASSED"<<endl;
  }
  
return ;
}

