//Hi Level Execution/Demonstration
/*
 * @file BenchMarking.cpp -- Benchmarking operations for operations in the PALISADE library.
 * @author  TPOC: palisade@njit.edu
 *
 * @section LICENSE
 *
 * Copyright (c) 2017, New Jersey Institute of Technology (NJIT)
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice, this
 * list of conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @section DESCRIPTION
 *
 */
#include <iostream>
#include <fstream>
#include <string>

#include "palisade.h"

#include "cryptocontexthelper.h"

#include "encoding/byteplaintextencoding.h"
#include "encoding/intplaintextencoding.h"


#include "utils/debug.h"

using namespace std;
using namespace lbcrypto;


void BenchMarking();
void BenchMarking_DCRT(bool intOrByteArray);
void BenchMarking_DCRT_Eval_Mult();
void BenchMarking_DCRT_Eval_Add();
void BenchMarking_Ring_Reduce_Single_Crt();
void BenchMarking_Encrypt_Single_Crt();
void BenchMarking_KeySwitch_Single_Crt();
void BenchMarking_Pre();
void Benchmarking_find_table_of_secure_params();
void PreComputeIntArray(usint minCycorder, usint maxCycorder, usint intArray_modulus);
bool checkSecureParams(const std::vector<BigBinaryInteger> &moduli, const usint towerSize, const usint ringDimension, std::map<double, std::map<usint, usint>> *deltaToRingdimensionToTowerSizeMapper, const std::vector<double> &deltas, BigBinaryInteger &multModuli);
std::string split(const std::string s, char c);
void standardMapTest();
void CalculateModuli(usint m);
int bitSizeCalculator(int n);
void ringReduceTest();
char getRandomChar();
void BenchMarking_SCRT(bool intOrByteArray);

/**
 * @brief Input parameters for PRE example.
 */
struct secureParams {
	usint m;			///< The ring parameter.
	BigBinaryInteger modulus;	///< The modulus
	BigBinaryInteger rootOfUnity;	///< The rootOfUnity
	usint relinWindow;		///< The relinearization window parameter.
};
static std::map<usint, std::map<usint, native64::BigBinaryInteger>> moduli; //first usint is cyc order, second map maps towersize to moduli
static std::map<usint, std::map<usint, native64::BigBinaryInteger>> rootsOfUnity; //first usint is cyc order, second map maps towersize to rootsOfUnity
static std::map<usint, std::map<usint, usint>> bitSizes; //first usint is cyc order, second map maps towersize to bitsize
static std::map<usint, IntPlaintextEncoding> cyclotomicOrderToIntArrayMapper; //used for encryption/decryption
static std::map<usint, BytePlaintextEncoding> cyclotomicOrderToByteArrayMapper; //used for encryption/decryption
static const char alphanum[] =
"0123456789"
"!@#$%^&*"
"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
"abcdefghijklmnopqrstuvwxyz"; //to generate a random string

static int stringLength = sizeof(alphanum) - 1;
static usint maxCyclotomicOrder = 4096;
static usint maxTowerSize = 20;
static usint numberOfIterations = 1;
static usint minCyclotomicOrder = 16;
static usint minTowerSize = 2;
static float stdDev = 4;
static int randSeed = 1;



#include <iterator>
int main() {
//	ringReduceTest();
	//	CalculateModuli();
	BenchMarking_DCRT(1);
//	BenchMarking_SCRT(1);
	//BenchMarking_DCRT_Eval_Mult();
//	BenchMarking_Pre();
//	Benchmarking_find_table_of_secure_params();
//	standardMapTest();
//	BenchMarking_DCRT_Eval_Mult();

	std::cin.get();

	return 0;
}

int bitSizeCalculator(int n) {
	if (n == -1) return 32;
	if (n == 0) return 1;
	int r = 0;
	while (n)
	{
		++r;
		n >>= 1;
	}
	return r;
}

char getRandomChar()  // Random string generator function.
{
	const usint seed = 2;
	srand(time(0) + randSeed++);
	return alphanum[rand() % stringLength];
}

void CalculateModuli(usint m) {

	double plaintextModulus = 2;
	double assuranceMeasureW = 6;
	double gaussianParameterR = 4;
	double q1;
	double q2;
	double sqrtn;
	double ringDimensionN;
	char c = '.';
	native64::BigBinaryInteger temp;

		std::map<usint, native64::BigBinaryInteger> towerToModuliOrRootOfUnity;
		moduli.insert(std::make_pair(m, towerToModuliOrRootOfUnity));
		rootsOfUnity.insert(std::make_pair(m, towerToModuliOrRootOfUnity));
		std::map<usint, usint> towerOrderToBitsMap;
		bitSizes.insert(std::make_pair(m, towerOrderToBitsMap));

		ringDimensionN = m / 2;
		sqrtn = sqrt(ringDimensionN);
		q1 = 4 * plaintextModulus * gaussianParameterR * sqrtn * assuranceMeasureW;
		q2 = 4 * pow(plaintextModulus, 2) * pow(gaussianParameterR, 5) * pow(sqrtn, 3) * pow(assuranceMeasureW, 5);

		native64::BigBinaryInteger q1BBI(split(to_string(q1), c));
		native64::BigBinaryInteger q2BBI(split(to_string(q2), c));

		NextQ(q1BBI, native64::BigBinaryInteger::TWO, m, native64::BigBinaryInteger("4"), native64::BigBinaryInteger("4"));
		NextQ(q2BBI, native64::BigBinaryInteger::TWO, m, native64::BigBinaryInteger("4"), native64::BigBinaryInteger("4"));
		cout << endl;
		for (usint i = 1; i <= maxTowerSize; i++) {
			std::vector<native64::BigBinaryInteger> moduli_vector_local(i);
			if (i == 1) {
				moduli[m][i] = q1BBI;
				rootsOfUnity[m][i] = RootOfUnity(m, q1BBI);
				}
			else if (i == 2) {
				moduli[m][i] = q2BBI;
				rootsOfUnity[m][i] = RootOfUnity(m, q2BBI);
				}
			else {
				temp = moduli[m][i - 1];
				NextQ(temp, native64::BigBinaryInteger::TWO, m, native64::BigBinaryInteger("4"), native64::BigBinaryInteger("4"));
				moduli[m][i] = temp;
				rootsOfUnity[m][i] = RootOfUnity(m, temp);
			}
			double doubleOfBBI = moduli[m][i].ConvertToDouble();
			double bitSize = floor(log(doubleOfBBI) / log(2)) + 1;
			bitSizes[m][i] = bitSize;
			if (i != 1) {
				std::vector<native64::BigBinaryInteger> moduliV;
				moduliV.reserve(i-1);
				for (usint j = 1; j <= i; j++) {
					moduliV.push_back(moduli[m][j]);
				}
			}
//		}
	}

	ofstream myfile;
	myfile.open("C:/Users/Ha/Documents/Code/Palisade/benchmark.csv", std::ios_base::app);
	myfile << "\n";
	myfile << "Bit size\n";
	myfile << "Cyclotomic Order,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768\n";

	for (usint i = minTowerSize; i <= maxTowerSize; i++) {
		myfile << "t=" << i << ",";
		for (usint cycOrder = minCyclotomicOrder; cycOrder <= maxCyclotomicOrder; cycOrder = cycOrder * 2) {
			myfile << bitSizes[cycOrder][i] << ",";
		}
		myfile << "\n";
	}
}

void PreComputeIntArray(usint minCycorder, usint maxCycorder, usint intArray_modulus) {
	cyclotomicOrderToIntArrayMapper.clear();
	for (usint m = minCycorder; m <= maxCyclotomicOrder; m = m * 2) {
		std::vector<uint32_t> randomValues;
		randomValues.reserve(m/2);
		for (usint i = 0; i < m/2; i++) {
			srand(time(0) + randSeed++);
			randomValues.push_back(rand() % intArray_modulus);
		}
		cyclotomicOrderToIntArrayMapper.insert(std::make_pair(m, randomValues));
	}
}

void PreComputeByteArray(usint minCycorder, usint maxCycorder) {
	cyclotomicOrderToByteArrayMapper.clear();
	for (usint m = minCycorder; m <= maxCyclotomicOrder; m = m * 2) {
		std::string x = "";
		for (usint i = 0; i < m / 2; i++) {
			x = x + getRandomChar();
		}
		cyclotomicOrderToByteArrayMapper.insert(std::make_pair(m, BytePlaintextEncoding(x)));
	}
}
//false for intArray true for ByteArray
void BenchMarking_DCRT(bool intOrByteArray){
	double diff, start, finish;
	std::map<usint, std::vector<double>> encryptTimer;
	std::map<usint, std::vector<double>> decryptTimer;
	std::map<usint, std::vector<double>> modReduceTimer;
	std::map<usint, std::vector<double>> ringReduceTimer;
	std::map<usint, std::vector<double>> keySwitchTimer;
	if (!intOrByteArray) {
		PreComputeIntArray(minCyclotomicOrder, maxCyclotomicOrder, 2);
	}
	else {
		PreComputeByteArray(minCyclotomicOrder, maxCyclotomicOrder);
	}

	for (usint m = minCyclotomicOrder; m <= maxCyclotomicOrder; m = m * 2) {
		CalculateModuli(m); // calculate moduli and precompute CRI factors
		std::vector<double> tower_timer(maxTowerSize + 1);
		std::fill(tower_timer.begin(), tower_timer.end(), 0);

		encryptTimer.insert(std::make_pair(m, tower_timer));
		modReduceTimer.insert(std::make_pair(m, tower_timer));
		ringReduceTimer.insert(std::make_pair(m, tower_timer));
		keySwitchTimer.insert(std::make_pair(m, tower_timer));
		decryptTimer.insert(std::make_pair(m, tower_timer));

		for (usint k = 0; k < numberOfIterations; k++) {
			for (usint i = minTowerSize; i <= maxTowerSize; i++) {
				/***************************SETUP START**********************************/
				cout << "Processing cyclotomic order of " << m << " and tower size of " << i << " under " << k << "th iteration" << endl;

				vector<native64::BigBinaryInteger> moduli_vector(i);

				vector<native64::BigBinaryInteger> rootsOfUnity_vector(i);

				for (int j = 0; j < i; j++) {
					moduli_vector[j] = moduli[m][j+1];
					rootsOfUnity_vector[j] = rootsOfUnity[m][j+1];
				}

				shared_ptr<ILDCRTParams> params(new ILDCRTParams(m, moduli_vector, rootsOfUnity_vector));

				LPCryptoParametersLTV<ILVectorArray2n> cryptoParams;
				cryptoParams.SetPlaintextModulus(BigBinaryInteger::TWO);
				cryptoParams.SetDistributionParameter(stdDev);
				cryptoParams.SetRelinWindow(1);
				cryptoParams.SetElementParams(params);

				CryptoContext<ILVectorArray2n> cc = CryptoContextFactory<ILVectorArray2n>::getCryptoContextDCRT(&cryptoParams);
				cc.Enable(ENCRYPTION);
				cc.Enable(SHE);
				cc.Enable(LEVELEDSHE);

				LPKeyPair<ILVectorArray2n> kp = cc.KeyGen();

				/***************************SETUP END**********************************/

				/***************************ENCRYPTION START**********************************/

				start = currentDateTime();
				vector<shared_ptr<Ciphertext<ILVectorArray2n>>> ciphertext;
				if (!intOrByteArray) {
					ciphertext = cc.Encrypt(kp.publicKey, cyclotomicOrderToIntArrayMapper.at(m), false);
				}
				else {
					cout << cyclotomicOrderToByteArrayMapper.at(m) << endl;
					ciphertext = cc.Encrypt(kp.publicKey, cyclotomicOrderToByteArrayMapper.at(m));
				}

				finish = currentDateTime();
				diff = finish - start;
				encryptTimer.at(m).at(i) += diff;

				/***************************ENCRYPTION END**********************************/
				/***************************DECRYPTION START**********************************/
				if (!intOrByteArray) {
					IntPlaintextEncoding plaintextNew;
					start = currentDateTime();

					cc.Decrypt(kp.secretKey, ciphertext, &plaintextNew);

					cout << "Decrypt " << plaintextNew << endl;

					finish = currentDateTime();
					diff = finish - start;
					decryptTimer.at(m).at(i) += diff;
				}
				else {
					BytePlaintextEncoding plaintextNew;
					start = currentDateTime();

					cc.Decrypt(kp.secretKey, ciphertext, &plaintextNew);

					cout << "Decrypt " << plaintextNew << endl;

					finish = currentDateTime();
					diff = finish - start;
					decryptTimer.at(m).at(i) += diff;
				}

				/***************************DECRYPTION END**********************************/
				/***************************KETSWITCH START**********************************/
				LPKeyPair<ILVectorArray2n> kp2 = cc.KeyGen();

				shared_ptr<LPEvalKey<ILVectorArray2n>> keySwitchHint;
				keySwitchHint = cc.KeySwitchGen(kp.secretKey, kp2.secretKey);

				start = currentDateTime();

				shared_ptr<Ciphertext<ILVectorArray2n>> cipherTextKeySwitch = cc.KeySwitch(keySwitchHint, ciphertext.at(0));

				finish = currentDateTime();
				diff = finish - start;
				keySwitchTimer.at(m).at(i) += diff;
				vector<shared_ptr<Ciphertext<ILVectorArray2n>>> cipherTextVector(1);
				cipherTextVector.at(0) = cipherTextKeySwitch;

				if (!intOrByteArray) {
					IntPlaintextEncoding plaintextNew_keyswitch_int;
					cc.Decrypt(kp2.secretKey, cipherTextVector, &plaintextNew_keyswitch_int);
					cout << "KeySwitch " << plaintextNew_keyswitch_int << endl;
				}

				else {
					BytePlaintextEncoding plaintextNew_keyswitch_byte;
					cc.Decrypt(kp2.secretKey, cipherTextVector, &plaintextNew_keyswitch_byte);
					cout << "KeySwitch " << plaintextNew_keyswitch_byte << endl;
				}
				
				/***************************KETSWITCH END**********************************/
				/***************************MODREDUCE START**********************************/
				if (i > 1) {
					vector<shared_ptr<Ciphertext<ILVectorArray2n>>> cipherTextModReduce(ciphertext);
					start = currentDateTime();

					cipherTextModReduce = cc.ModReduce(cipherTextModReduce);

					finish = currentDateTime();
					diff = finish - start;
					modReduceTimer.at(m).at(i) += diff;

					LPKeyPair<ILVectorArray2n> kp_modreduce(kp);

					ILVectorArray2n sk3PrivateElement(kp_modreduce.secretKey->GetPrivateElement());
					sk3PrivateElement.DropLastElement();
					kp_modreduce.secretKey->SetPrivateElement(sk3PrivateElement);

					if (!intOrByteArray) {
						IntPlaintextEncoding plaintextNew_modreduce;
						cc.Decrypt(kp_modreduce.secretKey, cipherTextModReduce, &plaintextNew_modreduce, false);
						cout << "Mod Reduce " << plaintextNew_modreduce << endl;
					}
					else {
						BytePlaintextEncoding plaintextNew_modreduce;
						cc.Decrypt(kp_modreduce.secretKey, cipherTextModReduce, &plaintextNew_modreduce);
						cout << "Mod Reduce " << plaintextNew_modreduce << endl;
					}
				}
			    /***************************MODREDUCE END**********************************/

				/***************************RINGREDUCE START**********************************/
				if (m > 16) {
					start = currentDateTime();

					LPKeyPair<ILVectorArray2n> kp_rr = cc.KeyGen();
					vector<shared_ptr<Ciphertext<ILVectorArray2n>>> cipherTextRingReduce;
					if (!intOrByteArray) {
						cipherTextRingReduce = cc.Encrypt(kp_rr.publicKey, cyclotomicOrderToIntArrayMapper.at(m), false);
					}
					else {
						cipherTextRingReduce = cc.Encrypt(kp_rr.publicKey, cyclotomicOrderToByteArrayMapper.at(m));
					}
					LPKeyPair<ILVectorArray2n> kp_sparse = cc.SparseKeyGen();

					shared_ptr<LPEvalKey<ILVectorArray2n>> keySwitchHint_sparse = cc.KeySwitchGen(kp_rr.secretKey, kp_sparse.secretKey);

					cipherTextRingReduce = cc.RingReduce(cipherTextRingReduce, keySwitchHint_sparse);

					finish = currentDateTime();
					diff = finish - start;
					ringReduceTimer.at(m).at(i) += diff;

					if (!intOrByteArray) {
						ILVectorArray2n skSparseElement(kp_sparse.secretKey->GetPrivateElement());
						skSparseElement.SwitchFormat();
						skSparseElement.Decompose();
						skSparseElement.SwitchFormat();

						kp_sparse.secretKey->SetPrivateElement(skSparseElement);

						IntPlaintextEncoding plaintextNew_ringreduce;

						cc.Decrypt(kp_sparse.secretKey, cipherTextRingReduce, &plaintextNew_ringreduce, false);

						cout << "Ring Reduce " << plaintextNew_ringreduce << endl;
					}
				}
				/***************************RINGREDUCE END**********************************/
			}
		
		}
	}
	
	ofstream myfile;
	myfile.open("C:/Users/Ha/Documents/Code/Palisade/benchmark.csv", std::ios_base::app);
	myfile << "\n";
	myfile << "Encrypt-Decrypt Double-CRT\n";
	myfile << "Cyclotomic Order";
	for (usint m = minCyclotomicOrder; m <= maxCyclotomicOrder; m = m * 2) {
		myfile << "," << m;
	}
	myfile << "\nEncrypt\n";

	for (usint i = minTowerSize; i <= maxTowerSize; i++) {
		myfile << "t=" << i << ",";
		for (usint m = minCyclotomicOrder; m <= maxCyclotomicOrder; m = m * 2) {
			myfile << encryptTimer.at(m).at(i)/numberOfIterations << ",";
		}
		myfile << "\n";
	}

	myfile << "\n";
	myfile << "Decrypt \n";
	for (usint i = minTowerSize; i <= maxTowerSize; i++) {
		myfile << "t=" << i << ",";
		for (usint m = minCyclotomicOrder; m <= maxCyclotomicOrder; m = m * 2) {
			myfile << decryptTimer.at(m).at(i)/numberOfIterations << ",";
		}
		myfile << "\n";
	}
	myfile << "\n" << numberOfIterations << " iterations\n";


	myfile << "\n";
	myfile << "ModReduce \n";
	for (usint i = minTowerSize; i <= maxTowerSize; i++) {
		myfile << "t=" << i << ",";
		for (usint m = minCyclotomicOrder; m <= maxCyclotomicOrder; m = m * 2) {
			myfile << modReduceTimer.at(m).at(i) / numberOfIterations << ",";
		}
		myfile << "\n";
	}
	myfile << "\n" << numberOfIterations << " iterations\n";

	myfile << "\n";
	myfile << "RingReduce \n";
	for (usint i = minTowerSize; i <= maxTowerSize; i++) {
		myfile << "t=" << i << ",";
		for (usint m = minCyclotomicOrder; m <= maxCyclotomicOrder; m = m * 2) {
			myfile << modReduceTimer.at(m).at(i) / numberOfIterations << ",";
		}
		myfile << "\n";
	}
	myfile << "\n" << numberOfIterations << " iterations\n";
}

/* false for intArray true for ByteArray*/
void BenchMarking_SCRT(bool intOrByteArray) {
	double diff, start, finish;
	std::map<usint, double> encryptTimer;
	std::map<usint, double> decryptTimer;
	std::map<usint, double> modReduceTimer;
	std::map<usint, double> ringReduceTimer;
	std::map<usint, double> keySwitchTimer;
	if (!intOrByteArray) {
		PreComputeIntArray(minCyclotomicOrder, maxCyclotomicOrder, 2);
	}
	else {
		PreComputeByteArray(minCyclotomicOrder, maxCyclotomicOrder);
	}

	for (usint m = minCyclotomicOrder; m <= maxCyclotomicOrder; m = m * 2) {
		CalculateModuli(m); // calculate moduli and precompute CRI factors
		double timer;

		encryptTimer.insert(std::make_pair(m, timer));
		modReduceTimer.insert(std::make_pair(m, timer));
		ringReduceTimer.insert(std::make_pair(m, timer));
		keySwitchTimer.insert(std::make_pair(m, timer));
		decryptTimer.insert(std::make_pair(m, timer));

		for (usint k = 0; k < numberOfIterations; k++) {
				/***************************SETUP START**********************************/
				cout << "Processing cyclotomic order of " << m << "under " << k << "th iteration" << endl;

				shared_ptr<native64::ILParams> params(new native64::ILParams(m, moduli[m][2], rootsOfUnity[m][2]));

				LPCryptoParametersLTV<native64::ILVector2n> cryptoParams;
				cryptoParams.SetPlaintextModulus(native64::BigBinaryInteger::TWO);
				cryptoParams.SetDistributionParameter(stdDev);
				cryptoParams.SetRelinWindow(1);
				cryptoParams.SetElementParams(params);

			//	CryptoContext<ILVector2n> cc = CryptoContextFactory<ILVector2n>::getCryptoContextDCRT(&cryptoParams);
				
				CryptoContext<ILVector2n> cc = CryptoContextFactory<ILVector2n>::genCryptoContextLTV(2, m,
					moduli[m][2].ToString(), rootsOfUnity[m][2].ToString(), 1, stdDev);
				cc.Enable(ENCRYPTION);
				cc.Enable(SHE);
				cc.Enable(LEVELEDSHE);

				LPKeyPair<ILVector2n> kp = cc.KeyGen();

				/***************************SETUP END**********************************/

				/***************************ENCRYPTION START**********************************/

				start = currentDateTime();
				vector<shared_ptr<Ciphertext<ILVector2n>>> ciphertext;
				if (!intOrByteArray) {
					ciphertext = cc.Encrypt(kp.publicKey, cyclotomicOrderToIntArrayMapper.at(m), false);
				}
				else {
					cout << cyclotomicOrderToByteArrayMapper.at(m) << endl;
					ciphertext = cc.Encrypt(kp.publicKey, cyclotomicOrderToByteArrayMapper.at(m));
				}

				finish = currentDateTime();
				diff = finish - start;
				encryptTimer.at(m) += diff;

				/***************************ENCRYPTION END**********************************/
				/***************************DECRYPTION START**********************************/
				if (!intOrByteArray) {
					IntPlaintextEncoding plaintextNew;
					start = currentDateTime();

					cc.Decrypt(kp.secretKey, ciphertext, &plaintextNew);

					cout << "Decrypt " << plaintextNew << endl;

					finish = currentDateTime();
					diff = finish - start;
					decryptTimer.at(m) += diff;
				}
				else {
					BytePlaintextEncoding plaintextNew;
					start = currentDateTime();

					cc.Decrypt(kp.secretKey, ciphertext, &plaintextNew);

					cout << "Decrypt " << plaintextNew << endl;

					finish = currentDateTime();
					diff = finish - start;
					decryptTimer.at(m) += diff;
				}

				/***************************DECRYPTION END**********************************/
				/***************************KETSWITCH START**********************************/
				LPKeyPair<ILVector2n> kp2 = cc.KeyGen();

				shared_ptr<LPEvalKey<ILVector2n>> keySwitchHint;
				keySwitchHint = cc.KeySwitchGen(kp.secretKey, kp2.secretKey);

				start = currentDateTime();

				shared_ptr<Ciphertext<ILVector2n>> cipherTextKeySwitch = cc.KeySwitch(keySwitchHint, ciphertext.at(0));

				finish = currentDateTime();
				diff = finish - start;
				keySwitchTimer.at(m) += diff;
				vector<shared_ptr<Ciphertext<ILVector2n>>> cipherTextVector(1);
				cipherTextVector.at(0) = cipherTextKeySwitch;

				if (!intOrByteArray) {
					IntPlaintextEncoding plaintextNew_keyswitch_int;
					cc.Decrypt(kp2.secretKey, cipherTextVector, &plaintextNew_keyswitch_int);
					cout << "KeySwitch " << plaintextNew_keyswitch_int << endl;
				}

				else {
					BytePlaintextEncoding plaintextNew_keyswitch_byte;
					cc.Decrypt(kp2.secretKey, cipherTextVector, &plaintextNew_keyswitch_byte);
					cout << "KeySwitch " << plaintextNew_keyswitch_byte << endl;
				}

				/***************************KETSWITCH END**********************************/
				

				/***************************RINGREDUCE START**********************************/
				if (m > 16) {
					start = currentDateTime();

					LPKeyPair<ILVector2n> kp_rr = cc.KeyGen();
					vector<shared_ptr<Ciphertext<ILVector2n>>> cipherTextRingReduce;
					if (!intOrByteArray) {
						cipherTextRingReduce = cc.Encrypt(kp_rr.publicKey, cyclotomicOrderToIntArrayMapper.at(m), false);
					}
					else {
						cipherTextRingReduce = cc.Encrypt(kp_rr.publicKey, cyclotomicOrderToByteArrayMapper.at(m));
					}
					LPKeyPair<ILVector2n> kp_sparse = cc.SparseKeyGen();

					shared_ptr<LPEvalKey<ILVector2n>> keySwitchHint_sparse = cc.KeySwitchGen(kp_rr.secretKey, kp_sparse.secretKey);

					cipherTextRingReduce = cc.RingReduce(cipherTextRingReduce, keySwitchHint_sparse);

					finish = currentDateTime();
					diff = finish - start;
					ringReduceTimer.at(m) += diff;

					if (!intOrByteArray) {
						ILVector2n skSparseElement(kp_sparse.secretKey->GetPrivateElement());
						skSparseElement.SwitchFormat();
						skSparseElement.Decompose();
						skSparseElement.SwitchFormat();

						kp_sparse.secretKey->SetPrivateElement(skSparseElement);

						IntPlaintextEncoding plaintextNew_ringreduce;

						cc.Decrypt(kp_sparse.secretKey, cipherTextRingReduce, &plaintextNew_ringreduce, false);

						cout << "Ring Reduce " << plaintextNew_ringreduce << endl;
					}
				}
				/***************************RINGREDUCE END**********************************/
		}
	}

	ofstream myfile;
	myfile.open("C:/Users/Ha/Documents/Code/Palisade/benchmark.csv", std::ios_base::app);
	myfile << "\n";
	myfile << "Encrypt-Decrypt Double-CRT\n";
	myfile << "Cyclotomic Order";
	for (usint m = minCyclotomicOrder; m <= maxCyclotomicOrder; m = m * 2) {
		myfile << "," << m;
	}
	myfile << "\nEncrypt\n,";

		for (usint m = minCyclotomicOrder; m <= maxCyclotomicOrder; m = m * 2) {
			myfile << encryptTimer.at(m) / numberOfIterations << ",";
		}
		myfile << "\n";
	

	myfile << "\n";
	myfile << "Decrypt\n,";
	
		for (usint m = minCyclotomicOrder; m <= maxCyclotomicOrder; m = m * 2) {
			myfile << decryptTimer.at(m) / numberOfIterations << ",";
		}
		myfile << "\n";
	
	myfile << "\n" << numberOfIterations << " iterations\n";

	myfile << "\n";
	myfile << "RingReduce\n,";
	usint mRing = 16;
	if (minCyclotomicOrder == 16) { 
		mRing = 32; myfile << ","; 
	}
	
	for (usint m = mRing; m <= maxCyclotomicOrder; m = m * 2) {
		myfile << ringReduceTimer.at(m) / numberOfIterations << ",";
	}
	
	myfile << "\n";
	myfile << "\n" << numberOfIterations << " iterations\n";

	myfile << "\n";
	myfile << "KeySwitch\n,";
	
	for (usint m = minCyclotomicOrder; m <= maxCyclotomicOrder; m = m * 2) {
		myfile << keySwitchTimer.at(m) / numberOfIterations << ",";
	}

	myfile << "\n";
	myfile << "\n" << numberOfIterations << " iterations\n";

}

void BenchMarking_DCRT_Eval_Mult() {
	double diff, start, finish;
	std::map<usint, std::vector<double>> evalMultTimerMap;

	for (usint m = minCyclotomicOrder; m <= maxCyclotomicOrder; m = m * 2) {

		std::vector<double> evalMultTimer(20);
		std::fill(evalMultTimer.begin(), evalMultTimer.end(), 0);
		evalMultTimerMap.insert(std::make_pair(m, evalMultTimer));
		CalculateModuli(m);

		ofstream myfile2;

		myfile2.open("C:/Users/Ha/Documents/Code/Palisade/results.txt", std::ios_base::app);
		myfile2 <<"\n" << m << "\n";


		for (usint k = 0; k < numberOfIterations; k++) {
			for (usint i = minTowerSize; i <= maxTowerSize; i++) {
				/***************************SETUP START**********************************/
				cout << "Processing cyclotomic order of " << m << " and tower size of " << i << " under " << k << "th iteration" << endl;

				vector<native64::BigBinaryInteger> moduli_vector(i);

				vector<native64::BigBinaryInteger> rootsOfUnity_vector(i);

				for (int j = 0; j < i; j++) {
					moduli_vector[j] = moduli[m][j + 1];
					rootsOfUnity_vector[j] = rootsOfUnity[m][j + 1];
				}

				DiscreteGaussianGenerator dgg(stdDev);

				shared_ptr<ILDCRTParams> params(new ILDCRTParams(m, moduli_vector, rootsOfUnity_vector));

				LPCryptoParametersLTV<ILVectorArray2n> cryptoParams;
				cryptoParams.SetPlaintextModulus(BigBinaryInteger::FIVE + BigBinaryInteger::FOUR);
				cryptoParams.SetDistributionParameter(stdDev);
				cryptoParams.SetRelinWindow(1);
				cryptoParams.SetElementParams(params);
				cryptoParams.SetAssuranceMeasure(6);
				cryptoParams.SetDepth(i - 1);
				cryptoParams.SetSecurityLevel(1.006);

				LPCryptoParametersLTV<ILVectorArray2n> finalParams;

				cryptoParams.ParameterSelection(&finalParams);

				usint n = finalParams.GetElementParams()->GetCyclotomicOrder();

				cout << "Cyclotomic order for final params is " << n << "and tower size is :" << i << endl;				
				myfile2 << "Cyclotomic order for final params is " << n << "and tower size is :" << i  << "\n";
				BigBinaryInteger modulus(finalParams.GetElementParams()->GetModulus());

				myfile2 << "Modulus value:" << modulus << "\n";

				CryptoContext<ILVectorArray2n> cc = CryptoContextFactory<ILVectorArray2n>::getCryptoContextDCRT(&finalParams);
				cc.Enable(SHE);
				cc.Enable(LEVELEDSHE);
				cc.Enable(ENCRYPTION);

				//Generate the secret key for the initial ciphertext:
				//LPKeyPair<ILVectorArray2n> kp;
				//
				////Generating new cryptoparameters for when modulus reduction is done. - not used?
				//std::vector<usint> vectorOfInts1(2048);
				//vectorOfInts1.at(0) = 2;
				//vectorOfInts1.at(1) = 4;
				//vectorOfInts1.at(2) = 0;
				//vectorOfInts1.at(3) = 0;
				//std::fill(vectorOfInts1.begin() + 4, vectorOfInts1.end(), 0);
				//IntPlaintextEncoding intArray1(vectorOfInts1);

				//std::vector<usint> vectorOfInts2(2048);
				//vectorOfInts2.at(0) = 3;
				//vectorOfInts2.at(1) = 3;
				//vectorOfInts2.at(2) = 0;
				//vectorOfInts2.at(3) = 0;
				//std::fill(vectorOfInts2.begin() + 4, vectorOfInts2.end(), 0);
				//IntPlaintextEncoding intArray2(vectorOfInts2);

				//kp = cc.KeyGen();

				//vector<shared_ptr<Ciphertext<ILVectorArray2n>>> ciphertext1;
				//vector<shared_ptr<Ciphertext<ILVectorArray2n>>> ciphertext2;

				//ciphertext1 = cc.Encrypt(kp.publicKey, intArray1, false);
				//ciphertext2 = cc.Encrypt(kp.publicKey, intArray2, false);

				//std::vector<shared_ptr<Ciphertext<ILVectorArray2n>>> cResult;
				//cResult.insert(cResult.begin(), cc.EvalMult(ciphertext1.at(0), ciphertext2.at(0)));

				//LPKeyPair<ILVectorArray2n> newKp = cc.KeyGen();

				//shared_ptr<LPEvalKey<ILVectorArray2n>> keySwitchHint1 = cc.EvalMultKeyGen(kp.secretKey);

				//cResult.at(0) = cc.KeySwitch(keySwitchHint1, cResult.at(0));

				//shared_ptr<LPEvalKey<ILVectorArray2n>> keySwitchHint2 = cc.KeySwitchGen(kp.secretKey, newKp.secretKey);

				//cResult.at(0) = cc.KeySwitch(keySwitchHint2, cResult.at(0));

				//IntPlaintextEncoding results;

				//cc.Decrypt(newKp.secretKey, cResult, &results, false);

				//cout << results.at(0) << endl;
				//cout << results.at(1) << endl;
				//cout << results.at(2) << endl;
				//
				//start = currentDateTime();


				//finish = currentDateTime();
				//diff = finish - start;
				//evalMultTimerMap.at(m).at(i) += diff;
			}
		}
	}
	ofstream myfile;
	myfile.open("C:/Users/Ha/Documents/Code/Palisade/benchmark.csv", std::ios_base::app);
	myfile << "\n";
	myfile << "EvalMult Double-CRT\n";
	myfile << "Cyclotomic Order,4096,8192,16384,\n";

	for (usint i = 4196; i <= 65536; i++) {
		myfile << "t=" << i << ",";
		for (usint m = 16; m <= maxCyclotomicOrder; m = m * 2) {
			myfile << evalMultTimerMap.at(m).at(i) / numberOfIterations << ",";
		}
		myfile << "\n";
	}

	myfile << "\n" << numberOfIterations << " iterations\n";
}
//
//void BenchMarking_DCRT_Eval_Add() {
//	double diff, start, finish;
//	std::map<usint, std::vector<double>> evalAddTimerMap;
//
//	usint numberOfIterations = 3;
//	usint numberOfTowers = 4;
//	usint maxCyclotomicOrder = 32768;
//
//	for (usint m = 16; m <= maxCyclotomicOrder; m = m * 2) {
//
//		std::vector<double> evalAddTimer(20);
//		std::fill(evalAddTimer.begin(), evalAddTimer.end(), 0);
//		evalAddTimerMap.insert(std::make_pair(m, evalAddTimer));
//
//		for (usint k = 0; k < numberOfIterations; k++) {
//			for (usint i = 1; i <= numberOfTowers; i++) {
//				float stdDev = 4;
//
//				vector<BigBinaryInteger> moduli(i);
//
//				vector<BigBinaryInteger> rootsOfUnity(i);
//
//				BigBinaryInteger q("1");
//				BigBinaryInteger temp;
//				BigBinaryInteger modulus("1");
//
//				for (int j = 0; j < i; j++) {
//					lbcrypto::NextQ(q, BigBinaryInteger::TWO, m, BigBinaryInteger("4"), BigBinaryInteger("4"));
//					moduli[j] = q;
//					rootsOfUnity[j] = RootOfUnity(m, moduli[j]);
//					modulus = modulus* moduli[j];
//				}
//
//				DiscreteGaussianGenerator dgg(stdDev);
//
//				ILDCRTParams params(m, moduli, rootsOfUnity);
//				ILVectorArray2n element1(dgg, params, Format::EVALUATION);
//				ILVectorArray2n element2(dgg, params, Format::EVALUATION);
//
//				LPCryptoParametersLTV<ILVectorArray2n> cryptoParams;
//				cryptoParams.SetPlaintextModulus(BigBinaryInteger::TWO);
//				cryptoParams.SetDistributionParameter(stdDev);
//				cryptoParams.SetRelinWindow(1);
//				cryptoParams.SetElementParams(params);
//				cryptoParams.SetDiscreteGaussianGenerator(dgg);
//
//				Ciphertext<ILVectorArray2n> cipherText1;
//				cipherText1.SetCryptoParameters(&cryptoParams);
//				cipherText1.SetElement(element1);
//
//				Ciphertext<ILVectorArray2n> cipherText2;
//				cipherText2.SetCryptoParameters(&cryptoParams);
//				cipherText2.SetElement(element2);
//
//				Ciphertext<ILVectorArray2n> results;
//				results.SetCryptoParameters(&cryptoParams);
//
//				LPPublicKeyEncryptionSchemeLTV<ILVectorArray2n> algorithm;
//
//				algorithm.Enable(SHE);
//
//				start = currentDateTime();
//
//				algorithm.EvalAdd(cipherText1, cipherText2, &results);
//
//				finish = currentDateTime();
//				diff = finish - start;
//				evalAddTimerMap.at(m).at(i) += diff;
//			}
//		}
//	}
//	ofstream myfile;
//	myfile.open("C:/Users/Ha/Documents/Code/Palisade/benchmark.csv", std::ios_base::app);
//	myfile << "\n";
//	myfile << "EvalAdd Double-CRT\n";
//	myfile << "Cyclotomic Order,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768\n";
//
//	for (usint i = 1; i <= numberOfTowers; i++) {
//		myfile << "t=" << i << ",";
//		for (usint m = 16; m <= maxCyclotomicOrder; m = m * 2) {
//			myfile << evalAddTimerMap.at(m).at(i) / numberOfIterations << ",";
//		}
//		myfile << "\n";
//	}
//
//	myfile << "\n" << numberOfIterations << " iterations\n";
//}
//




//void BenchMarking_Pre(){
//	double diff, start, finish;
//	std::map<usint, double> reEncryptTimer;
//
//	usint numberOfIterations = 3;
//
//	std::vector<BytePlaintextEncoding> plaintextEncodingVector;
//	std:map<usint, BytePlaintextEncoding> cyclotomicOrderToByteArrayMapper;
//
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(16, BytePlaintextEncoding("A")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(32, BytePlaintextEncoding("AB")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(64, BytePlaintextEncoding("ABCD")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(128, BytePlaintextEncoding("ABCDEFGH")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(256, BytePlaintextEncoding("ABCDEFGHIJKLMNOP")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(512, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(1024, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(2048, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(4096, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(8192, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(16384, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(32768, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//
//	for (usint m = 16; m <= 64; m = m * 2) {
//
//		double temp = 0;
//		reEncryptTimer.insert(std::make_pair(m, temp));
//
//		for (usint k = 0; k < numberOfIterations; k++) {
//			float stdDev = 4;
//
//			BigBinaryInteger q("1");
//			BigBinaryInteger temp;
//
//			lbcrypto::NextQ(q, BigBinaryInteger::TWO, m, BigBinaryInteger("4"), BigBinaryInteger("4"));
//
//			DiscreteGaussianGenerator dgg(stdDev);
//			BigBinaryInteger rootOfUnity(RootOfUnity(m, q));
//			ILParams params(m, q, RootOfUnity(m, q));
//
//			//This code is run only when performing execution time measurements
//
//			//Precomputations for FTT
//			ChineseRemainderTransformFTT<BigBinaryInteger,BigBinaryVector>::GetInstance().PreCompute(rootOfUnity, m, q);
//
//			//Precomputations for DGG
//			ILVector2n::PreComputeDggSamples(dgg, params);
//
//			LPCryptoParametersLTV<ILVector2n> cryptoParams;
//			cryptoParams.SetPlaintextModulus(BigBinaryInteger::TWO); // Set plaintext modulus.
//			cryptoParams.SetDistributionParameter(stdDev);          // Set the noise parameters.
//			cryptoParams.SetRelinWindow(1);						   // Set the relinearization window
//			cryptoParams.SetElementParams(params);                // Set the initialization parameters.
//			cryptoParams.SetDiscreteGaussianGenerator(dgg);         // Create the noise generator
//
//			Ciphertext<ILVector2n> cipherText;
//			cipherText.SetCryptoParameters(&cryptoParams);
//
//			LPPublicKeyEncryptionSchemeLTV<ILVector2n> algorithm;
//			LPPublicKey<ILVector2n> pk(cryptoParams);
//			LPPrivateKey<ILVector2n> sk(cryptoParams);
//
//			algorithm.Enable(ENCRYPTION);
//			algorithm.Enable(PRE);
//
//			algorithm.KeyGen(&pk, &sk);
//
//			vector<Ciphertext<ILVector2n>> ciphertext;
//
//			start = currentDateTime();
//
//			CryptoUtility<ILVector2n>::Encrypt(algorithm, pk, cyclotomicOrderToByteArrayMapper.at(m), &ciphertext);
//
//			LPPublicKey<ILVector2n> newPK(cryptoParams);
//			LPPrivateKey<ILVector2n> newSK(cryptoParams);
//
//			algorithm.KeyGen(&newPK, &newSK);	// This is the same core key generation operation.
//
//			LPEvalKeyNTRURelin<ILVector2n> evalKey(cryptoParams);
//
//			algorithm.ReKeyGen(newPK, sk, &evalKey);  // This is the core re-encryption operation.
//
//			vector<Ciphertext<ILVector2n>> newCiphertext;
//
//			start = currentDateTime();
//
//			CryptoUtility<ILVector2n>::ReEncrypt(algorithm, evalKey, ciphertext, &newCiphertext);  // This is the core re-encryption operation.
//
//			finish = currentDateTime();
//			diff = finish - start;
//			reEncryptTimer.at(m) += diff;
//
//			BytePlaintextEncoding plaintextNew;
//
//			CryptoUtility<ILVector2n>::Decrypt(algorithm, newSK, newCiphertext, &plaintextNew);  // This is the core decryption operation.
//
//			cout << plaintextNew << endl;
//
//		}
//		ILVector2n::DestroyPreComputedSamples();
//	}
//
//	for (usint m = 16; m <= 64; m = m * 2) {
//		cout << "m is :" << m << endl;
//		cout << reEncryptTimer.at(m) / numberOfIterations << endl;
//	}	cout << endl;
//}
//
//void BenchMarking_ComposedEvalMult(){}
//void BenchMarking_KeySwitch_Single_Crt(){
//	double diff, start, finish;
//	std::map<usint, double> keySwitchTimer;
//
//	usint numberOfIterations = 3;
//	usint numberOfTowers = 20;
//
//	std::vector<BytePlaintextEncoding> plaintextEncodingVector;
//    std:map<usint, BytePlaintextEncoding> cyclotomicOrderToByteArrayMapper;
//
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(16, BytePlaintextEncoding("A")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(32, BytePlaintextEncoding("AB")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(64, BytePlaintextEncoding("ABCD")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(128, BytePlaintextEncoding("ABCDEFGH")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(256, BytePlaintextEncoding("ABCDEFGHIJKLMNOP")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(512, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(1024, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(2048, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(4096, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(8192, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(16384, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//	cyclotomicOrderToByteArrayMapper.insert(std::make_pair(32768, BytePlaintextEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFABCDEFGHIJKLMNOPQRSTUVWXYZABCDEF")));
//
//	for (usint m = 16; m <= 64; m = m * 2) {
//
//		double temp = 0;
//		keySwitchTimer.insert(std::make_pair(m, temp));
//
//		for (usint k = 0; k < numberOfIterations; k++) {
//			float stdDev = 4;
//
//			BigBinaryInteger q("1");
//			BigBinaryInteger temp;
//
//			lbcrypto::NextQ(q, BigBinaryInteger::TWO, m, BigBinaryInteger("10"), BigBinaryInteger("10"));
//
//			DiscreteGaussianGenerator dgg(stdDev);
//			BigBinaryInteger rootOfUnity(RootOfUnity(m, q));
//			ILParams params(m, q, RootOfUnity(m, q));
//
//			//This code is run only when performing execution time measurements
//
//			//Precomputations for FTT
//			ChineseRemainderTransformFTT<BigBinaryInteger,BigBinaryVector>::GetInstance().PreCompute(rootOfUnity, m, q);
//
//			//Precomputations for DGG
//			ILVector2n::PreComputeDggSamples(dgg, params);
//
//			LPCryptoParametersLTV<ILVector2n> cryptoParams;
//			cryptoParams.SetPlaintextModulus(BigBinaryInteger::TWO); // Set plaintext modulus.
//			cryptoParams.SetDistributionParameter(stdDev);          // Set the noise parameters.
//			cryptoParams.SetRelinWindow(1);						   // Set the relinearization window
//			cryptoParams.SetElementParams(params);                // Set the initialization parameters.
//			cryptoParams.SetDiscreteGaussianGenerator(dgg);         // Create the noise generator
//
//			Ciphertext<ILVector2n> cipherText;
//			cipherText.SetCryptoParameters(&cryptoParams);
//
//			LPPublicKeyEncryptionSchemeLTV<ILVector2n> algorithm;
//			LPPublicKey<ILVector2n> pk(cryptoParams);
//			LPPrivateKey<ILVector2n> sk(cryptoParams);
//
//			algorithm.Enable(ENCRYPTION);
//			algorithm.Enable(LEVELEDSHE);
//
//			algorithm.KeyGen(&pk, &sk);
//
//			vector<Ciphertext<ILVector2n>> ciphertext;
//
//			start = currentDateTime();
//
//			CryptoUtility<ILVector2n>::Encrypt(algorithm, pk, cyclotomicOrderToByteArrayMapper.at(m), &ciphertext);
//
//			LPPublicKey<ILVector2n> pkNew(cryptoParams);
//			LPPrivateKey<ILVector2n> skNew(cryptoParams);
//
//			algorithm.KeyGen(&pkNew, &skNew);
//
//			finish = currentDateTime();
//			diff = finish - start;
//			keySwitchTimer.at(m) += diff;
//
//			start = currentDateTime();
//
//			vector<Ciphertext<ILVector2n>> keySwitchedCiphertext;
//
//			LPEvalKeyNTRU<ILVector2n> keySwitchHint(cryptoParams);
//			algorithm.EvalMultKeyGen(sk, skNew, &keySwitchHint);
//
//			start = currentDateTime();
//
//			CryptoUtility<ILVector2n>::KeySwitch(algorithm, keySwitchHint, ciphertext, &keySwitchedCiphertext);
//
//			finish = currentDateTime();
//			diff = finish - start;
//			keySwitchTimer.at(m) += diff;
//
//			BytePlaintextEncoding plaintextNew;
//
//			CryptoUtility<ILVector2n>::Decrypt(algorithm, skNew, keySwitchedCiphertext, &plaintextNew);
//
//			cout << plaintextNew << endl;
//
//		}
//	}
//
//	for (usint m = 16; m <= 64; m = m * 2) {
//		cout << "m is :" << m << endl;
//		cout << keySwitchTimer.at(m) / numberOfIterations << endl;
//	}	cout << endl;
//}
//

//void Benchmarking_find_table_of_secure_params() {
//	
//	double plaintextModulus = 2;
//	double assuranceMeasureW = 6;
//	double gaussianParameterR = 4;
//	std::map<double, std::map<usint, usint>> deltaToRingdimensiontoTowersizeMapper;// delta to (ringdimension to towersize) mapper
//	std::vector<double> deltas;
//	deltas.reserve(1);
//	deltas.push_back(1.007);
////	deltas.push_back(1.006);
//
//	std::map<usint, usint> ringDimensionToTowersizeMapper;
//
//	for (usint i = 0; i < deltas.size(); i++) {
//		deltaToRingdimensiontoTowersizeMapper.insert(std::make_pair(deltas.at(i), ringDimensionToTowersizeMapper));
//	}
//
//	double q1;
//	double q2;
//	double sqrtn;
//	double ringDimensionN;
//	BigBinaryInteger temp;
//	usint maxTowerSize = 9;
//	usint maxM = 32768;
//	char c = '.';
//
//		for (usint m = 2048; m <= maxM; m = m * 2) {
//			std::vector<BigBinaryInteger> moduli;
//			ringDimensionN = m / 2;
//			sqrtn = sqrt(ringDimensionN);
//			q1 = 4 * plaintextModulus * gaussianParameterR * sqrtn * assuranceMeasureW;
//			q2 = 4 * pow(plaintextModulus, 2) * pow(gaussianParameterR, 5) * pow(sqrtn, 3) * pow(assuranceMeasureW, 5);
//		
//			BigBinaryInteger q1Big(split(to_string(q1), c));
//			BigBinaryInteger q2Big(split(to_string(q2), c));
//			
//			lbcrypto::NextQ(q1Big, BigBinaryInteger::TWO, m, BigBinaryInteger("4"), BigBinaryInteger("4"));
//			lbcrypto::NextQ(q2Big, BigBinaryInteger::TWO, m, BigBinaryInteger("4"), BigBinaryInteger("4"));
//			
//			moduli.push_back(BigBinaryInteger::ZERO);
//			moduli.push_back(q1Big);
//			moduli.push_back(q2Big);
//			moduli.reserve(maxTowerSize + 1);
//			BigBinaryInteger modulusMult(q1Big);
//
//			for (usint towerSize = 1; towerSize <= maxTowerSize; towerSize++) {
//				if (towerSize != 1 && towerSize != 2) {
//					temp = moduli[towerSize - 1];
//					lbcrypto::NextQ(temp, BigBinaryInteger::TWO, m, BigBinaryInteger("4"), BigBinaryInteger("4"));
//					moduli[towerSize] = temp;
//					modulusMult = modulusMult * temp;
//					
//				}
//
//				else if(towerSize == 2){
//					modulusMult = modulusMult * BigBinaryInteger(q2Big);
//				}
//				checkSecureParams(moduli, towerSize, ringDimensionN, &deltaToRingdimensiontoTowersizeMapper, deltas, modulusMult);
//
//			}
//	}
//		for (usint i = 0; i < deltas.size();i++ ) {
//			
//			cout << "Printing delta " << deltas.at(i)<< endl;
//			std::map<usint, usint> deltaVector = deltaToRingdimensiontoTowersizeMapper.at(deltas.at(i));
//			
//			map<usint, usint>::iterator it;
//			for (it = deltaVector.begin(); it != deltaVector.end(); it++)
//			{
//				std::cout << it->first << ':' << it->second << std::endl;
//			}
//		}
//}

bool checkSecureParams(const std::vector<BigBinaryInteger> &moduli, const usint towerSize, const usint ringDimension, std::map<double, std::map<usint, usint>> *deltaToRingdimensionToTowerSizeMapper, const std::vector<double> &deltas, BigBinaryInteger &multModuli) {
	double modulusMultDouble = multModuli.ConvertToDouble();
	double logOfModulusMult = log(modulusMultDouble) / log(2);

	for (usint i = 0; i < deltas.size(); i++) {
		double logDelta = 4 * (log(deltas.at(i)) / log(2));
		double securityFactorCheck = logOfModulusMult / logDelta;
		if ((ringDimension-securityFactorCheck) > 0.0001) {
			(*deltaToRingdimensionToTowerSizeMapper)[deltas.at(i)][ringDimension] = towerSize;
		}
	}
}

std::string split(const std::string s, char c) {
	std::string result;
	const char *str = s.c_str();
	const char *begin = str;
	while (*str != c && *str)
		str++;
	result = std::string(begin, str);
	return result;
}

void standardMapTest() {
	std::map<double, std::map<usint, usint>> deltaToRingdimensionToTowerSizeMapper;
	usint a = 1;
	usint b = 2;

	std::map<usint, usint> aToX;
	std::map<usint, usint> bToX;

	deltaToRingdimensionToTowerSizeMapper.insert(std::make_pair(a, aToX));
	deltaToRingdimensionToTowerSizeMapper.insert(std::make_pair(b, bToX));

	deltaToRingdimensionToTowerSizeMapper[a].insert(std::make_pair(a, 0));
	deltaToRingdimensionToTowerSizeMapper[a].insert(std::make_pair(a+1, 1));
	deltaToRingdimensionToTowerSizeMapper[a].insert(std::make_pair(a+2, 2));


	deltaToRingdimensionToTowerSizeMapper[b].insert(std::make_pair(b, 0));
	deltaToRingdimensionToTowerSizeMapper[b].insert(std::make_pair(b + 1, 1));
	deltaToRingdimensionToTowerSizeMapper[b].insert(std::make_pair(b + 2, 2));

	map<double , map<usint, usint>>::iterator it;
	for (it = deltaToRingdimensionToTowerSizeMapper.begin(); it != deltaToRingdimensionToTowerSizeMapper.end(); it++)
	{
		cout << "Map for value: " << it->first << endl;
		std::map<usint, usint> maps = it->second;
		map<usint, usint>::iterator itInner;

		for (itInner = maps.begin(); itInner != maps.end(); itInner++) {
			cout << itInner->first << ":" << itInner->second << endl;
			}

	}

}

