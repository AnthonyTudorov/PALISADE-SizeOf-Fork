/** * @file * @author  TPOC: Dr. Kurt Rohloff <rohloff@njit.edu>, * Programmers: Dr. Yuriy Polyakov, <polyakov@njit.edu>, Gyana Sahu * <grs22@njit.edu> * @version 00_03 * * @section LICENSE *  * Copyright (c) 2015, New Jersey Institute of Technology (NJIT) * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: 1. Redistributions of source code must retain the above * copyright notice, this list of conditions and the following * disclaimer.  2. Redistributions in binary form must reproduce the * above copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT * HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH * DAMAGE. * * @section DESCRIPTION * * This file contains the main class for unsigned big integers: ubint. Big * integers are represented as arrays of machine native unsigned integers. The * native integer type is supplied as a template parameter.  Currently * implementation based on uint32_t and uint64_t is * supported. a native double the base integer size is also needed. */#ifndef LBCRYPTO_MATH_MGMPINT_MGMPINT_H#define LBCRYPTO_MATH_MGMPINT_MGMPINT_H#include <iostream>#include <string>#include <vector>#include <type_traits>#include <typeinfo>#include <limits>#include <fstream>#include <stdexcept>#include <functional>#include <memory>#include "../../utils/inttypes.h"#include "../../utils/memory.h"#include "time.h"#include <chrono>#include "../../utils/debug.h"#include <NTL/ZZ_p.h>#include <NTL/ZZ_limbs.h>/** *@namespace NTL * The namespace of this code */namespace NTL{  class myZZ_p : public NTL::ZZ_p {  public:    myZZ_p();    myZZ_p(int a);    myZZ_p(long a);    myZZ_p(unsigned long a);    myZZ_p(const unsigned int &a);    myZZ_p(unsigned int &a);    //myZZ_p(INIT_SIZE_TYPE, long k);    myZZ_p(std::string s);    myZZ_p(const char * s);    myZZ_p(NTL::ZZ &a);    myZZ_p(NTL::ZZ &&a);    myZZ_p(const NTL::ZZ &a);    myZZ_p(NTL::ZZ_p &a);    myZZ_p(const NTL::ZZ_p &a);    myZZ_p(NTL::ZZ_p &&a);    //  myZZ_p_p& operator=(const myZZ_p &rhs);    //myZZ_p( ZZ_p && zzin) : ZZ_p(zzin), m_MSB(5){};    static const myZZ_p ZERO;    static const myZZ_p ONE;    static const myZZ_p TWO;    static const myZZ_p THREE;    static const myZZ_p FOUR;    static const myZZ_p FIVE;    //  void InitMyZZ_p(ZZ_p &&zzin) const {this->m_MSB = 1; return;}    //adapter kit    usint GetMSB();    static const myZZ_p& zero();    //palisade conversion methods     usint ConvertToUsint() const;    usint ConvertToInt() const;    uint32_t ConvertToUint32() const;    uint64_t ConvertToUint64() const;    float ConvertToFloat() const;    double ConvertToDouble() const;    long double ConvertToLongDouble() const;    //stopped here: it has problems finding which clear to use    //read  http://www.prenhall.com/divisions/esm/app/kafura/secure/chapter7/html/7.5_inheritance.htm    //and see if we can figure out what happened.    //inline void clear(myZZ_p& a) { clear(*this);}; //why can't I inherit this?    //inline void clear(myZZ_p& a) { clear(a);}; //this compiled but calls ZZ_p:clear in perpetual loop.       //comparison method inline for speed    inline sint Compare(const myZZ_p& a) const {return compare(this->_ZZ_p__rep,a._ZZ_p__rep); };    //palisade arithmetic methods all inline for speed    inline myZZ_p operator+(const myZZ_p &b) const {      myZZ_p tmp;      add(tmp, *this, b);      return tmp ;    };    inline myZZ_p Add(const myZZ_p& b) const {return *this+b;};    inline myZZ_p Plus(const myZZ_p& b) const {return *this+b;}; //to be deprecated    inline myZZ_p Sub(const myZZ_p& b) const  {return(*this-b);};      inline myZZ_p Minus(const myZZ_p& b) const  {return(*this-b);}; //to be deprecated    inline myZZ_p operator-(const myZZ_p &b) const {      myZZ_p tmp;      sub(tmp, *this, b);      return tmp ;    };    inline myZZ_p& operator -=(const myZZ_p &a) {      *this = *this-a;      return *this;    };      inline myZZ_p Mul(const myZZ_p& b) const {return *this*b;};    inline myZZ_p Times(const myZZ_p& b) const {return *this*b;}; //to be deprecated    inline myZZ_p Div(const myZZ_p& b) const {return *this/b;};    inline myZZ_p DividedBy(const myZZ_p& b) const {return *this/b;};    inline myZZ_p Exp(const usint p) const {return power(*this,p);};#if 0    inline myZZ_p operator-(const myZZ_p &b) const {      myZZ_p tmp;      sub(tmp, *this, b);      return tmp ;    };#endif      //palisade modular arithmetic methods all inline for speed    //note b can't be ZZ_p cause it can't hold it's modulus value.    inline myZZ_p operator%(const myZZ &b) const    {      myZZ_p res;      res = (this->_ZZ_p__rep)%b;      return(res);    };    //note Mod() == ModBarrett() of all forms.     inline myZZ_p Mod(const myZZ& modulus) const {return (this->_ZZ_p__rep)%modulus;};    inline myZZ_p ModBarrett(const myZZ& modulus, const myZZ& mu) const {return (this->_ZZ_p__rep)%modulus;};    inline    myZZ_p ModBarrett(const myZZ& modulus, const myZZ mu_arr[BARRETT_LEVELS+1]) const  {return (this->_ZZ_p__rep)%modulus;};    inline myZZ_p ModInverse(const myZZ& modulus) const { return InvMod(this->_ZZ_p__rep,modulus);};     inline myZZ_p ModAdd(const myZZ_p& b, const myZZ& modulus) const {return AddMod(this->_ZZ_p__rep%modulus, b._ZZ_p__rep%modulus, modulus);};    inline myZZ_p ModSub(const myZZ_p& b, const myZZ& modulus) const    {      myZZ_p newthis(*this%modulus);      myZZ newb(b._ZZ_p__rep%modulus);      return SubMod(newthis._ZZ_p__rep, newb, modulus);          };    inline myZZ_p ModMul(const myZZ_p& b, const myZZ& modulus) const {return MulMod(this->_ZZ_p__rep, b._ZZ_p__rep, modulus);};    inline myZZ_p ModBarrettMul(const myZZ_p& b, const myZZ& modulus,const myZZ_p& mu) const {return MulMod(this->_ZZ_p__rep, b._ZZ_p__rep, modulus);};    inline myZZ_p ModBarrettMul(const myZZ_p& b, const myZZ& modulus,const myZZ mu_arr[BARRETT_LEVELS]) const  {return MulMod(this->_ZZ_p__rep, b._ZZ_p__rep, modulus);};    inline myZZ_p ModExp(const myZZ_p& b, const myZZ& modulus) const {return PowerMod(this->_ZZ_p__rep, b._ZZ_p__rep, modulus);};    //palisade string conversion    const std::string ToString() const;	  private:    //adapter kits    void SetMSB();        size_t m_MSB;        usint GetMSBLimb_t( ZZ_limb_t x);    void m_setOTM(const myZZ &q);    bool m_checkOTM(const myZZ &q) const;    myZZ& m_getOTM(void) const;        static myZZ m_OTM;        enum OTMState {      GARBAGE,INITIALIZED //note different order, Garbage is the default state    };    //enum to store the state of the    static OTMState m_OTM_state;      }; //class ends  }//namespace ends#endif //LBCRYPTO_MATH_MGMPINT_MGMPINT_H